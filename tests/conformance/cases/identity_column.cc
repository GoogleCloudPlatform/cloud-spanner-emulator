//
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

#include <string>
#include <utility>
#include <vector>

#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "zetasql/base/testing/status_matchers.h"
#include "tests/common/proto_matchers.h"
#include "absl/status/status.h"
#include "absl/strings/string_view.h"
#include "absl/strings/substitute.h"
#include "tests/common/scoped_feature_flags_setter.h"
#include "tests/conformance/common/database_test_base.h"

namespace google {
namespace spanner {
namespace emulator {
namespace test {

namespace {

using ::testing::ContainsRegex;
using ::testing::HasSubstr;
using ::zetasql_base::testing::StatusIs;

class IdentityColumnTest
    : public DatabaseTest,
      public testing::WithParamInterface<database_api::DatabaseDialect> {
 public:
  IdentityColumnTest() : feature_flags_({.enable_identity_columns = true}) {}

  void SetUp() override {
    dialect_ = GetParam();
    DatabaseTest::SetUp();
  }

  absl::Status SetUpDatabase() override {
    return SetSchemaFromFile("identity_column.test");
  }

 private:
  test::ScopedEmulatorFeatureFlagsSetter feature_flags_;
};

INSTANTIATE_TEST_SUITE_P(
    PerDialectIdentityColumnTests, IdentityColumnTest,
    testing::Values(database_api::DatabaseDialect::GOOGLE_STANDARD_SQL,
                    database_api::DatabaseDialect::POSTGRESQL),
    [](const testing::TestParamInfo<IdentityColumnTest::ParamType>& info) {
      return database_api::DatabaseDialect_Name(info.param);
    });

TEST_P(IdentityColumnTest, Basic) {
  ZETASQL_ASSERT_OK(
      CommitDml({SqlStatement("INSERT INTO t(value) VALUES (1), (2), (3)")}));
  // Check that counter has incremented at least 3 times.
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    ASSERT_THAT(
        Query("SELECT spanner.GET_TABLE_COLUMN_IDENTITY_STATE('t.id') >= 3"),
        IsOkAndHoldsRows({{true}}));
  } else {
    ASSERT_THAT(Query("SELECT GET_TABLE_COLUMN_IDENTITY_STATE('t.id') >= 3"),
                IsOkAndHoldsRows({{true}}));
  }
}

TEST_P(IdentityColumnTest, StartWithCounter) {
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
      CREATE TABLE test (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY (
          BIT_REVERSED_POSITIVE START COUNTER WITH 1000),
        value BIGINT,
        PRIMARY KEY(id)
      ))"}));
    ZETASQL_ASSERT_OK(CommitDml(
        {SqlStatement("INSERT INTO test(value) VALUES (1), (2), (3)")}));
    ASSERT_THAT(
        Query("SELECT spanner.GET_TABLE_COLUMN_IDENTITY_STATE('test.id') >= "
              "1003"),
        IsOkAndHoldsRows({{true}}));
  } else {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
      CREATE TABLE test (
        id INT64 GENERATED BY DEFAULT AS IDENTITY (
          BIT_REVERSED_POSITIVE START COUNTER WITH 1000),
        value INT64,
      ) PRIMARY KEY(id))"}));
    ZETASQL_ASSERT_OK(CommitDml(
        {SqlStatement("INSERT INTO test(value) VALUES (1), (2), (3)")}));
    ASSERT_THAT(
        Query("SELECT GET_TABLE_COLUMN_IDENTITY_STATE('test.id') >= 1003"),
        IsOkAndHoldsRows({{true}}));
  }
}

TEST_P(IdentityColumnTest, SkipRange) {
  // We only test if the DDL/DML works correctly but not the range is actually
  // skipped.
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
      CREATE TABLE test (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY (
          BIT_REVERSED_POSITIVE SKIP RANGE 1000 2000),
        value BIGINT,
        PRIMARY KEY(id)
      ))"}));
    ZETASQL_ASSERT_OK(CommitDml(
        {SqlStatement("INSERT INTO test(value) VALUES (1), (2), (3)")}));
    ASSERT_THAT(Query(R"(
      SELECT COUNT(spanner.BIT_REVERSE(id, true))
      FROM test WHERE id >= 1000 AND id <= 2000)"),
                IsOkAndHoldsRows({{0}}));
  } else {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
      CREATE TABLE test (
        id INT64 GENERATED BY DEFAULT AS IDENTITY (
          BIT_REVERSED_POSITIVE SKIP RANGE 1000, 2000),
        value INT64,
      ) PRIMARY KEY(id))"}));
    ZETASQL_ASSERT_OK(CommitDml(
        {SqlStatement("INSERT INTO test(value) VALUES (1), (2), (3)")}));
    ASSERT_THAT(Query(R"(
      SELECT COUNT(BIT_REVERSE(id, true))
      FROM test WHERE id >= 1000 AND id <= 2000)"),
                IsOkAndHoldsRows({{0}}));
  }
}

TEST_P(IdentityColumnTest, NamedSchema) {
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    ZETASQL_ASSERT_OK(UpdateSchema({"CREATE SCHEMA s",
                            R"(
                            CREATE TABLE s.t (
                              id BIGINT GENERATED BY DEFAULT AS IDENTITY (
                                BIT_REVERSED_POSITIVE),
                              value BIGINT,
                              PRIMARY KEY(id)
                            ))"}));
  } else {
    ZETASQL_ASSERT_OK(UpdateSchema({"CREATE SCHEMA s",
                            R"(
                            CREATE TABLE s.t (
                              id INT64 GENERATED BY DEFAULT AS IDENTITY (
                                BIT_REVERSED_POSITIVE),
                              value INT64,
                            ) PRIMARY KEY(id))"}));
  }
  ZETASQL_ASSERT_OK(
      CommitDml({SqlStatement("INSERT INTO s.t(value) VALUES (1), (2), (3)")}));
}

TEST_P(IdentityColumnTest, SameTableColumnNameDifferentSchemas) {
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    ZETASQL_ASSERT_OK(UpdateSchema({"CREATE SCHEMA s1",
                            R"(
        CREATE TABLE s1.test_table (
          id BIGINT GENERATED BY DEFAULT AS IDENTITY (BIT_REVERSED_POSITIVE),
          non_key_col BIGINT GENERATED BY DEFAULT AS IDENTITY (
            BIT_REVERSED_POSITIVE),
          value BIGINT,
          PRIMARY KEY(id)))"}));
    ZETASQL_ASSERT_OK(UpdateSchema({"CREATE SCHEMA s2",
                            R"(
        CREATE TABLE s2.test_table (
          id BIGINT GENERATED BY DEFAULT AS IDENTITY (BIT_REVERSED_POSITIVE),
          non_key_col BIGINT GENERATED BY DEFAULT AS IDENTITY (
            BIT_REVERSED_POSITIVE),
          value BIGINT,
          PRIMARY KEY(id)))"}));
    ZETASQL_ASSERT_OK(Insert("s1.test_table", {"value"}, {1}));
    ZETASQL_ASSERT_OK(Insert("s1.test_table", {"value"}, {2}));
    ZETASQL_ASSERT_OK(Insert("s1.test_table", {"value"}, {3}));
    ASSERT_THAT(
        Query(
            "SELECT "
            "spanner.GET_TABLE_COLUMN_IDENTITY_STATE('s1.test_table.id') >= 3"),
        IsOkAndHoldsRows({{true}}));
    ZETASQL_ASSERT_OK(Insert("s2.test_table", {"value"}, {1}));
    ZETASQL_ASSERT_OK(Insert("s2.test_table", {"value"}, {2}));
    ZETASQL_ASSERT_OK(Insert("s2.test_table", {"value"}, {3}));
    ASSERT_THAT(
        Query(
            "SELECT "
            "spanner.GET_TABLE_COLUMN_IDENTITY_STATE('s2.test_table.id') >= 3"),
        IsOkAndHoldsRows({{true}}));
  } else {
    ZETASQL_ASSERT_OK(UpdateSchema({"CREATE SCHEMA s1",
                            R"(
        CREATE TABLE s1.test_table (
          id INT64 GENERATED BY DEFAULT AS IDENTITY (BIT_REVERSED_POSITIVE),
          non_key_col INT64 GENERATED BY DEFAULT AS IDENTITY (
            BIT_REVERSED_POSITIVE),
          value INT64
        ) PRIMARY KEY(id))"}));
    ZETASQL_ASSERT_OK(UpdateSchema({"CREATE SCHEMA s2",
                            R"(
        CREATE TABLE s2.test_table (
          id INT64 GENERATED BY DEFAULT AS IDENTITY (BIT_REVERSED_POSITIVE),
          non_key_col INT64 GENERATED BY DEFAULT AS IDENTITY (
            BIT_REVERSED_POSITIVE),
          value INT64
        ) PRIMARY KEY(id))"}));
    ZETASQL_ASSERT_OK(Insert("s1.test_table", {"value"}, {1}));
    ZETASQL_ASSERT_OK(Insert("s1.test_table", {"value"}, {2}));
    ZETASQL_ASSERT_OK(Insert("s1.test_table", {"value"}, {3}));
    ASSERT_THAT(
        Query(
            "SELECT GET_TABLE_COLUMN_IDENTITY_STATE('s1.test_table.id') >= 3"),
        IsOkAndHoldsRows({{true}}));
    ZETASQL_ASSERT_OK(Insert("s2.test_table", {"value"}, {1}));
    ZETASQL_ASSERT_OK(Insert("s2.test_table", {"value"}, {2}));
    ZETASQL_ASSERT_OK(Insert("s2.test_table", {"value"}, {3}));
    ASSERT_THAT(
        Query(
            "SELECT GET_TABLE_COLUMN_IDENTITY_STATE('s2.test_table.id') >= 3"),
        IsOkAndHoldsRows({{true}}));
  }
}

TEST_P(IdentityColumnTest, InformationSchema) {
  // We verify that identity-owned sequences are considered as system objects so
  // that they should not be visible in the information schema tables.
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
        CREATE TABLE test_table (
          id BIGINT GENERATED BY DEFAULT AS IDENTITY (
            BIT_REVERSED_POSITIVE START COUNTER WITH 1000 SKIP RANGE 1 12345),
          non_key_col BIGINT GENERATED BY DEFAULT AS IDENTITY (
            BIT_REVERSED_POSITIVE START COUNTER WITH 123),
          PRIMARY KEY(id)))"}));
    EXPECT_THAT(Query("SELECT * FROM INFORMATION_SCHEMA.SEQUENCES"),
                IsOkAndHoldsRows({}));
    EXPECT_THAT(Query(R"(SELECT column_name, column_default, is_identity,
          identity_generation, identity_kind, identity_start_with_counter,
          identity_skip_range_min, identity_skip_range_max
          FROM INFORMATION_SCHEMA.COLUMNS WHERE table_name = 'test_table')"),
                IsOkAndHoldsRows(
                    {{"id", Null<std::string>(), "YES", "BY DEFAULT",
                      "BIT_REVERSED_POSITIVE_SEQUENCE", "1000", "1", "12345"},
                     {"non_key_col", Null<std::string>(), "YES", "BY DEFAULT",
                      "BIT_REVERSED_POSITIVE_SEQUENCE", "123",
                      Null<std::string>(), Null<std::string>()}}));
  } else {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
        CREATE TABLE test_table (
          id INT64 GENERATED BY DEFAULT AS IDENTITY (
            BIT_REVERSED_POSITIVE START COUNTER WITH 1000 SKIP RANGE 1, 12345),
          non_key_col INT64 GENERATED BY DEFAULT AS IDENTITY (
            BIT_REVERSED_POSITIVE START COUNTER WITH 123)
        ) PRIMARY KEY(id))"}));

    EXPECT_THAT(Query("SELECT * FROM INFORMATION_SCHEMA.SEQUENCES"),
                IsOkAndHoldsRows({}));
    EXPECT_THAT(Query("SELECT * FROM INFORMATION_SCHEMA.SEQUENCE_OPTIONS"),
                IsOkAndHoldsRows({}));
    EXPECT_THAT(Query(R"(SELECT column_name, column_default, is_identity,
          identity_generation, identity_kind, identity_start_with_counter,
          identity_skip_range_min, identity_skip_range_max
          FROM INFORMATION_SCHEMA.COLUMNS where table_name = 'test_table')"),
                IsOkAndHoldsRows(
                    {{"id", Null<std::string>(), "YES", "BY DEFAULT",
                      "BIT_REVERSED_POSITIVE_SEQUENCE", "1000", "1", "12345"},
                     {"non_key_col", Null<std::string>(), "YES", "BY DEFAULT",
                      "BIT_REVERSED_POSITIVE_SEQUENCE", "123",
                      Null<std::string>(), Null<std::string>()}}));
  }
}

TEST_P(IdentityColumnTest, InformationSchemaView) {
  // Create a view on a table with identity columns.
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
        CREATE TABLE test_table (
          key_col BIGINT GENERATED BY DEFAULT AS IDENTITY (
            BIT_REVERSED_POSITIVE START COUNTER WITH 1000 SKIP RANGE 1 12345),
          non_key_col BIGINT GENERATED BY DEFAULT AS IDENTITY (
            BIT_REVERSED_POSITIVE START COUNTER WITH 123),
          PRIMARY KEY(key_col)))",
                            R"(
      CREATE VIEW test_view SQL SECURITY INVOKER AS
        SELECT t.key_col, t.non_key_col FROM test_table t
      )"}));
  } else {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
        CREATE TABLE test_table (
          key_col INT64 GENERATED BY DEFAULT AS IDENTITY (
            BIT_REVERSED_POSITIVE START COUNTER WITH 1000 SKIP RANGE 1, 12345),
          non_key_col INT64 GENERATED BY DEFAULT AS IDENTITY (
            BIT_REVERSED_POSITIVE START COUNTER WITH 123)
        ) PRIMARY KEY(key_col))",
                            R"(CREATE VIEW test_view SQL SECURITY INVOKER AS
        SELECT t.key_col, t.non_key_col FROM test_table t)"}));
  }
  EXPECT_THAT(
      Query(R"(SELECT column_name, is_identity,
          identity_generation, identity_kind, identity_start_with_counter,
          identity_skip_range_min, identity_skip_range_max
          FROM INFORMATION_SCHEMA.COLUMNS where table_name = 'test_view')"),
      IsOkAndHoldsRows(
          {{"key_col", "NO", Null<std::string>(), Null<std::string>(),
            Null<std::string>(), Null<std::string>(), Null<std::string>()},
           {"non_key_col", "NO", Null<std::string>(), Null<std::string>(),
            Null<std::string>(), Null<std::string>(), Null<std::string>()}}));
}

TEST_P(IdentityColumnTest, InformationSchemaSequenceTablesForNamedSchemas) {
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    ZETASQL_ASSERT_OK(UpdateSchema({"CREATE SCHEMA s1",
                            R"(
        CREATE TABLE s1.test_table (
          id BIGINT GENERATED BY DEFAULT AS IDENTITY (
            BIT_REVERSED_POSITIVE START COUNTER WITH 1000 SKIP RANGE 1 12345),
          non_key_col BIGINT GENERATED BY DEFAULT AS IDENTITY (
            BIT_REVERSED_POSITIVE START COUNTER WITH 123),
          PRIMARY KEY(id)))"}));
    ZETASQL_ASSERT_OK(UpdateSchema({"CREATE SCHEMA s2",
                            R"(
        CREATE TABLE s2.test_table (
          id BIGINT GENERATED BY DEFAULT AS IDENTITY (
            BIT_REVERSED_POSITIVE START COUNTER WITH 1000 SKIP RANGE 1 12345),
          non_key_col BIGINT GENERATED BY DEFAULT AS IDENTITY (
            BIT_REVERSED_POSITIVE START COUNTER WITH 123),
          PRIMARY KEY(id)))"}));
    EXPECT_THAT(Query("SELECT * FROM INFORMATION_SCHEMA.SEQUENCES"),
                IsOkAndHoldsRows({}));
  } else {
    ZETASQL_ASSERT_OK(UpdateSchema({"CREATE SCHEMA s1",
                            R"(
        CREATE TABLE s1.test_table (
          id INT64 GENERATED BY DEFAULT AS IDENTITY (
            BIT_REVERSED_POSITIVE START COUNTER WITH 1000 SKIP RANGE 1, 12345),
          non_key_col INT64 GENERATED BY DEFAULT AS IDENTITY (
            BIT_REVERSED_POSITIVE START COUNTER WITH 123)
        ) PRIMARY KEY(id))"}));
    ZETASQL_ASSERT_OK(UpdateSchema({"CREATE SCHEMA s2",
                            R"(
        CREATE TABLE s2.test_table (
          id INT64 GENERATED BY DEFAULT AS IDENTITY (
            BIT_REVERSED_POSITIVE START COUNTER WITH 1000 SKIP RANGE 1, 12345),
          non_key_col INT64 GENERATED BY DEFAULT AS IDENTITY (
            BIT_REVERSED_POSITIVE START COUNTER WITH 123)
        ) PRIMARY KEY(id))"}));

    EXPECT_THAT(Query("SELECT * FROM INFORMATION_SCHEMA.SEQUENCES"),
                IsOkAndHoldsRows({}));
    EXPECT_THAT(Query("SELECT * FROM INFORMATION_SCHEMA.SEQUENCE_OPTIONS"),
                IsOkAndHoldsRows({}));
  }
}

TEST_P(IdentityColumnTest, InformationSchemaColumnsTableForNamedSchemas) {
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    ZETASQL_ASSERT_OK(UpdateSchema({"CREATE SCHEMA s1",
                            R"(
          CREATE TABLE s1.test_table (
            id BIGINT GENERATED BY DEFAULT AS IDENTITY (
              BIT_REVERSED_POSITIVE START COUNTER WITH 100 SKIP RANGE 200 300),
            non_key_col BIGINT GENERATED BY DEFAULT AS IDENTITY (
              BIT_REVERSED_POSITIVE START COUNTER WITH 400),
            PRIMARY KEY(id)))"}));
    ZETASQL_ASSERT_OK(UpdateSchema({"CREATE SCHEMA s2",
                            R"(
          CREATE TABLE s2.test_table (
            id BIGINT GENERATED BY DEFAULT AS IDENTITY (
              BIT_REVERSED_POSITIVE START COUNTER WITH 500 SKIP RANGE 600 700),
            non_key_col BIGINT GENERATED BY DEFAULT AS IDENTITY (
              BIT_REVERSED_POSITIVE START COUNTER WITH 800),
            PRIMARY KEY(id)))"}));
  } else {
    ZETASQL_ASSERT_OK(UpdateSchema({"CREATE SCHEMA s1",
                            R"(
        CREATE TABLE s1.test_table (
        id INT64 GENERATED BY DEFAULT AS IDENTITY (
          BIT_REVERSED_POSITIVE START COUNTER WITH 100 SKIP RANGE 200, 300),
        non_key_col INT64 GENERATED BY DEFAULT AS IDENTITY (
          BIT_REVERSED_POSITIVE START COUNTER WITH 400)
      ) PRIMARY KEY(id))"}));
    ZETASQL_ASSERT_OK(UpdateSchema({"CREATE SCHEMA s2",
                            R"(
        CREATE TABLE s2.test_table (
        id INT64 GENERATED BY DEFAULT AS IDENTITY (
          BIT_REVERSED_POSITIVE START COUNTER WITH 500 SKIP RANGE 600, 700),
        non_key_col INT64 GENERATED BY DEFAULT AS IDENTITY (
          BIT_REVERSED_POSITIVE START COUNTER WITH 800)
      ) PRIMARY KEY(id))"}));
  }
  EXPECT_THAT(
      Query(R"(SELECT column_name, is_identity,
          identity_generation, identity_kind, identity_start_with_counter,
          identity_skip_range_min, identity_skip_range_max
          FROM INFORMATION_SCHEMA.COLUMNS where table_schema = 's1'
          and table_name = 'test_table')"),
      IsOkAndHoldsRows({{"id", "YES", "BY DEFAULT",
                         "BIT_REVERSED_POSITIVE_SEQUENCE", "100", "200", "300"},
                        {"non_key_col", "YES", "BY DEFAULT",
                         "BIT_REVERSED_POSITIVE_SEQUENCE", "400",
                         Null<std::string>(), Null<std::string>()}}));
  EXPECT_THAT(
      Query(R"(SELECT column_name, is_identity,
          identity_generation, identity_kind, identity_start_with_counter,
          identity_skip_range_min, identity_skip_range_max
          FROM INFORMATION_SCHEMA.COLUMNS where table_schema = 's2'
          and table_name = 'test_table')"),
      IsOkAndHoldsRows({{"id", "YES", "BY DEFAULT",
                         "BIT_REVERSED_POSITIVE_SEQUENCE", "500", "600", "700"},
                        {"non_key_col", "YES", "BY DEFAULT",
                         "BIT_REVERSED_POSITIVE_SEQUENCE", "800",
                         Null<std::string>(), Null<std::string>()}}));
}

TEST_P(IdentityColumnTest, InformationSchemaWithDefaultSequenceKind) {
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    // When using the default_sequence_kind option, identity_kind should be
    // null.
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
      ALTER DATABASE db
      SET spanner.default_sequence_kind = 'bit_reversed_positive')",
                            R"(
      CREATE TABLE test_table (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        value BIGINT
      ))"}));
  } else {
    // When using the default_sequence_kind option, identity_kind should be
    // null.
    ZETASQL_ASSERT_OK(UpdateSchema({R"(ALTER DATABASE db SET OPTIONS (
        default_sequence_kind = 'bit_reversed_positive'))",
                            R"(CREATE TABLE test_table (
        id INT64 GENERATED BY DEFAULT AS IDENTITY,
        value INT64
      ) PRIMARY KEY(id))"}));
  }
  EXPECT_THAT(
      Query(R"(SELECT column_name, is_identity,
          identity_generation, identity_kind, identity_start_with_counter,
          identity_skip_range_min, identity_skip_range_max
          FROM INFORMATION_SCHEMA.COLUMNS where table_name = 'test_table')"),
      IsOkAndHoldsRows({
          {"id", "YES", "BY DEFAULT", Null<std::string>(), Null<std::string>(),
           Null<std::string>(), Null<std::string>()},
          {"value", "NO", Null<std::string>(), Null<std::string>(),
           Null<std::string>(), Null<std::string>(), Null<std::string>()},
      }));
}

TEST_P(IdentityColumnTest, DropDefault) {
  // Verify that DROP DEFAULT does not remove the identity column.
  ZETASQL_ASSERT_OK(UpdateSchema({"ALTER TABLE t ALTER COLUMN id DROP DEFAULT"}));
  ZETASQL_ASSERT_OK(
      CommitDml({SqlStatement("INSERT INTO t(value) VALUES (1), (2), (3)")}));
  // Check that counter has incremented at least 3 times.
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    ASSERT_THAT(
        Query("SELECT spanner.GET_TABLE_COLUMN_IDENTITY_STATE('t.id') >= 3"),
        IsOkAndHoldsRows({{true}}));
  } else {
    ASSERT_THAT(Query("SELECT GET_TABLE_COLUMN_IDENTITY_STATE('t.id') >= 3"),
                IsOkAndHoldsRows({{true}}));
  }
}

TEST_P(IdentityColumnTest, DropTable) {
  ZETASQL_ASSERT_OK(UpdateSchema({"DROP TABLE t"}));
}

TEST_P(IdentityColumnTest, DropIdentityColumn) {
  ZETASQL_ASSERT_OK(UpdateSchema({"ALTER TABLE t DROP COLUMN non_key_col"}));
}

TEST_P(IdentityColumnTest, IdentityColumnFunction) {
  ZETASQL_ASSERT_OK(
      CommitDml({SqlStatement("INSERT INTO t(value) VALUES (1), (2), (3)")}));

  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    EXPECT_THAT(
        Query("SELECT spanner.get_table_column_identity_state('T.id') >= 3"),
        IsOkAndHoldsRows({{true}}));
    // Case insensitive.
    EXPECT_THAT(
        Query("SELECT spanner.get_table_column_identity_state('t.ID') >= 3"),
        IsOkAndHoldsRows({{true}}));
    // Non-identity columns.
    EXPECT_THAT(
        Query("SELECT spanner.get_table_column_identity_state('T.value')"),
        StatusIs(absl::StatusCode::kInvalidArgument,
                 "Identity column not found in table T: value"));
  } else {
    EXPECT_THAT(Query(R"(SELECT GET_TABLE_COLUMN_IDENTITY_STATE("T.id") >= 3)"),
                IsOkAndHoldsRows({{true}}));
    // Case insensitive.
    EXPECT_THAT(Query(R"(SELECT GET_TABLE_COLUMN_IDENTITY_STATE("t.ID") >= 3)"),
                IsOkAndHoldsRows({{true}}));
    // Non-identity columns.
    EXPECT_THAT(Query("SELECT GET_TABLE_COLUMN_IDENTITY_STATE('T.value')"),
                StatusIs(absl::StatusCode::kInvalidArgument,
                         "Identity column not found in table T: value"));
  }
}

TEST_P(IdentityColumnTest, IdentityColumnFunctionInvalidCases) {
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(CREATE SCHEMA Sch)",
                            R"(
      CREATE TABLE Sch.T (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY (
          BIT_REVERSED_POSITIVE START COUNTER WITH 3001),
        default_col BIGINT DEFAULT (1),
        value BIGINT,
        PRIMARY KEY(id)
      ))"}));

    ZETASQL_ASSERT_OK(
        CommitDml({SqlStatement("INSERT INTO t(value) VALUES (1), (2), (3)")}));

    const std::vector<std::pair<std::string, std::string>> invalid_cases = {
        // Non-identity columns.
        {"SELECT spanner.get_table_column_identity_state('sch.T.value')",
         "Identity column not found in table sch.T: value"},
        {"SELECT spanner.get_table_column_identity_state('sch.T.default_col')",
         "Identity column not found in table sch.T: default_col"},
        // Invalid format.
        {"SELECT spanner.get_table_column_identity_state('id')",
         "The column identifier's format is invalid: id."},
        {"SELECT spanner.get_table_column_identity_state('unknown.sch.t.id')",
         "The column identifier's format is invalid: unknown.sch.t.id."},
        {"SELECT spanner.get_table_column_identity_state('..sch.t.id')",
         "The column identifier's format is invalid: ..sch.t.id."},
        // Not support backticks.
        {"SELECT spanner.get_table_column_identity_state('`T`.`id`')",
         "Table not found for the GET_TABLE_COLUMN_IDENTITY_STATE function: "
         "`T`"},
        // Unknown tables or columns.
        {"SELECT spanner.get_table_column_identity_state('T.unknown_column')",
         "Identity column not found in table T: unknown_column"},
        {"SELECT spanner.get_table_column_identity_state('sch.T.unknown_col')",
         "Identity column not found in table sch.T: unknown_col"}};

    for (const auto& [sql, error_message] : invalid_cases) {
      EXPECT_THAT(Query(sql), StatusIs(absl::StatusCode::kInvalidArgument,
                                       testing::HasSubstr(error_message)));
    }
  } else {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(CREATE SCHEMA Sch)",
                            R"(CREATE TABLE Sch.T (
        id INT64 GENERATED BY DEFAULT AS IDENTITY (
          BIT_REVERSED_POSITIVE START COUNTER WITH 3001),
        default_col INT64 DEFAULT (1),
        value INT64
      ) PRIMARY KEY(id))"}));

    ZETASQL_ASSERT_OK(
        CommitDml({SqlStatement("INSERT INTO t(value) VALUES (1), (2), (3)")}));

    const std::vector<std::pair<std::string, std::string>> invalid_cases = {
        // Non-identity columns.
        {"select GET_TABLE_COLUMN_IDENTITY_STATE(\"sch.T.value\")",
         "Identity column not found in table sch.T: value"},
        {"select GET_TABLE_COLUMN_IDENTITY_STATE(\"sch.T.default_col\")",
         "Identity column not found in table sch.T: default_col"},
        // Invalid format.
        {"select GET_TABLE_COLUMN_IDENTITY_STATE(\"id\")",
         "The column identifier's format is invalid: id."},
        {"select GET_TABLE_COLUMN_IDENTITY_STATE(\"unknown.sch.t.id\")",
         "The column identifier's format is invalid: unknown.sch.t.id."},
        {"select GET_TABLE_COLUMN_IDENTITY_STATE(\"..sch.t.id\")",
         "The column identifier's format is invalid: ..sch.t.id."},
        // Not support backticks.
        {"select GET_TABLE_COLUMN_IDENTITY_STATE(\"`T`.`id`\")",
         "Table not found for the GET_TABLE_COLUMN_IDENTITY_STATE function: "
         "`T`"},
        // Unknown tables or columns.
        {"select GET_TABLE_COLUMN_IDENTITY_STATE(\"T.unknown_column\")",
         "Identity column not found in table T: unknown_column"},
        {"select GET_TABLE_COLUMN_IDENTITY_STATE(\"sch.T.unknown_col\")",
         "Identity column not found in table sch.T: unknown_col"}};

    for (const auto& [sql, error_message] : invalid_cases) {
      EXPECT_THAT(Query(sql), StatusIs(absl::StatusCode::kInvalidArgument,
                                       HasSubstr(error_message)));
    }
  }
}

TEST_P(IdentityColumnTest, IdentityColumnFunctionWithNamedSchema) {
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(CREATE SCHEMA Sch)",
                            R"(
                CREATE TABLE Sch.T (
                  id BIGINT GENERATED BY DEFAULT AS IDENTITY (
                    BIT_REVERSED_POSITIVE START COUNTER WITH 3001),
                  value BIGINT,
                  PRIMARY KEY(id)
                ))"}));
    ZETASQL_ASSERT_OK(CommitDml(
        {SqlStatement("INSERT INTO sch.t(value) VALUES (1), (2), (3)")}));
    // Check that counter has incremented at least 3 times.
    EXPECT_THAT(
        Query("SELECT spanner.get_table_column_identity_state('sch.t.id') "
              ">= 3003"),
        IsOkAndHoldsRows({{true}}));
  } else {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(CREATE SCHEMA Sch)",
                            R"(CREATE TABLE Sch.T (
        id INT64 GENERATED BY DEFAULT AS IDENTITY (
          BIT_REVERSED_POSITIVE START COUNTER WITH 3001),
        value INT64
      ) PRIMARY KEY(id))"}));
    ZETASQL_ASSERT_OK(CommitDml(
        {SqlStatement("INSERT INTO sch.t(value) VALUES (1), (2), (3)")}));
    // Check that counter has incremented at least 3 times.
    EXPECT_THAT(Query("SELECT get_table_column_identity_state('sch.t.id') "
                      ">= 3003"),
                IsOkAndHoldsRows({{true}}));
  }
}

TEST_P(IdentityColumnTest, AddColumnBackfillWithNonNullValues) {
  ZETASQL_ASSERT_OK(
      CommitDml({SqlStatement("INSERT INTO t(value) VALUES (1), (2), (3)")}));
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(ALTER TABLE t ADD COLUMN another_id BIGINT
            GENERATED BY DEFAULT AS IDENTITY (
            BIT_REVERSED_POSITIVE START COUNTER WITH 1000))"}));
    ZETASQL_ASSERT_OK(
        CommitDml({SqlStatement("INSERT INTO t(value) VALUES (4), (5), (6)")}));
    // Check that counter has incremented at least 6 times.
    EXPECT_THAT(
        Query("SELECT spanner.get_table_column_identity_state('t.another_id') "
              ">= 1006"),
        IsOkAndHoldsRows({{true}}));
  } else {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(ALTER TABLE t ADD COLUMN another_id INT64
            GENERATED BY DEFAULT AS IDENTITY (
            BIT_REVERSED_POSITIVE START COUNTER WITH 1000))"}));
    ZETASQL_ASSERT_OK(
        CommitDml({SqlStatement("INSERT INTO t(value) VALUES (4), (5), (6)")}));
    // Check that counter has incremented at least 6 times.
    EXPECT_THAT(
        Query("SELECT get_table_column_identity_state('t.another_id') >= 1006"),
        IsOkAndHoldsRows({{true}}));
  }
}

TEST_P(IdentityColumnTest, AddNotNullColumnBackfillWithNonNullValues) {
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    // Create table with a not null identity column.
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
      CREATE TABLE test_table (
        id BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY (
                                              BIT_REVERSED_POSITIVE),
        value BIGINT,
        PRIMARY KEY(id)))"}));

    ZETASQL_ASSERT_OK(CommitDml(
        {SqlStatement("INSERT INTO test_table(value) VALUES (1), (2), (3)")}));

    // Add another not null identity column.
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
                ALTER TABLE test_table
                  ADD COLUMN not_null_id BIGINT NOT NULL
                          GENERATED BY DEFAULT AS IDENTITY (
                          BIT_REVERSED_POSITIVE START COUNTER WITH 2000))"}));

    ZETASQL_ASSERT_OK(CommitDml(
        {SqlStatement("INSERT INTO test_table(value) VALUES (4), (5), (6)")}));

    // Check that counter has incremented at least 6 times.
    ASSERT_THAT(Query("SELECT "
                      "spanner.GET_TABLE_COLUMN_IDENTITY_STATE('test_table.not_"
                      "null_id') >= 2006"),
                IsOkAndHoldsRows({{true}}));
  } else {
    // Create table with a not null identity column.
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
      CREATE TABLE test_table (
        id INT64 NOT NULL GENERATED BY DEFAULT AS IDENTITY (
                                                      BIT_REVERSED_POSITIVE),
        value INT64
        ) PRIMARY KEY(id))"}));

    ZETASQL_ASSERT_OK(CommitDml(
        {SqlStatement("INSERT INTO test_table(value) VALUES (1), (2), (3)")}));

    // Add another not null identity column.
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
                ALTER TABLE test_table
                  ADD COLUMN not_null_id INT64 NOT NULL
                          GENERATED BY DEFAULT AS IDENTITY (
                          BIT_REVERSED_POSITIVE START COUNTER WITH 2000))"}));

    ZETASQL_ASSERT_OK(CommitDml(
        {SqlStatement("INSERT INTO test_table(value) VALUES (4), (5), (6)")}));

    // Check that counter has incremented at least 6 times.
    ASSERT_THAT(
        Query(
            "SELECT GET_TABLE_COLUMN_IDENTITY_STATE('test_table.not_null_id') "
            ">= 2006"),
        IsOkAndHoldsRows({{true}}));
  }
}

TEST_P(IdentityColumnTest, AlterEntireIdentityColumn) {
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    // ALTER COLUMN doesn't support altering an entire identity column.
    // See: ALTER COLUMN in
    // https://cloud.google.com/spanner/docs/reference/postgresql/data-definition-language#alter_table
    GTEST_SKIP();
  } else {
    ZETASQL_ASSERT_OK(
        CommitDml({SqlStatement("INSERT INTO t(value) VALUES (1), (2), (3)")}));

    // Check that counter has incremented at least 3 times.
    EXPECT_THAT(Query("SELECT get_table_column_identity_state('t.id') >= 3"),
                IsOkAndHoldsRows({{true}}));

    ZETASQL_ASSERT_OK(UpdateSchema({R"(ALTER TABLE t ALTER COLUMN id INT64
            GENERATED BY DEFAULT AS IDENTITY (
            BIT_REVERSED_POSITIVE START COUNTER WITH 1000))"}));

    ZETASQL_ASSERT_OK(
        CommitDml({SqlStatement("INSERT INTO t(value) VALUES (4), (5), (6)")}));

    // Check that counter has incremented at least 3 times from 1000.
    EXPECT_THAT(Query("SELECT get_table_column_identity_state('t.id') >= 1003"),
                IsOkAndHoldsRows({{true}}));
  }
}

TEST_P(IdentityColumnTest, AlterIdentityColumnRestartCounter) {
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    ZETASQL_ASSERT_OK(
        CommitDml({SqlStatement("INSERT INTO t(value) VALUES (1), (2), (3)")}));

    // Check that counter has incremented at least 3 times.
    EXPECT_THAT(
        Query("SELECT spanner.get_table_column_identity_state('t.id') >= 3"),
        IsOkAndHoldsRows({{true}}));

    ZETASQL_ASSERT_OK(UpdateSchema({R"(ALTER TABLE T ALTER COLUMN id
                            RESTART COUNTER WITH 1000)"}));
    ZETASQL_ASSERT_OK(
        CommitDml({SqlStatement("INSERT INTO t(value) VALUES (4), (5), (6)")}));

    // Check that counter has incremented at least 3 times from 1000.
    EXPECT_THAT(
        Query("SELECT spanner.get_table_column_identity_state('t.id') >= 1003"),
        IsOkAndHoldsRows({{true}}));
  } else {
    ZETASQL_ASSERT_OK(
        CommitDml({SqlStatement("INSERT INTO t(value) VALUES (1), (2), (3)")}));

    // Check that counter has incremented at least 3 times.
    EXPECT_THAT(Query("SELECT get_table_column_identity_state('t.id') >= 3"),
                IsOkAndHoldsRows({{true}}));

    ZETASQL_ASSERT_OK(UpdateSchema({R"(ALTER TABLE t ALTER COLUMN id
                            ALTER IDENTITY RESTART COUNTER WITH 1000)"}));
    ZETASQL_ASSERT_OK(
        CommitDml({SqlStatement("INSERT INTO t(value) VALUES (4), (5), (6)")}));

    // Check that counter has incremented at least 3 times from 1000.
    EXPECT_THAT(Query("SELECT get_table_column_identity_state('t.id') >= 1003"),
                IsOkAndHoldsRows({{true}}));
  }
}

TEST_P(IdentityColumnTest, AlterIdentityColumnSkipRange) {
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(ALTER TABLE t ALTER COLUMN id
                            SET SKIP RANGE 3000 5000)"}));
  } else {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(ALTER TABLE t ALTER COLUMN id
                            ALTER IDENTITY SET SKIP RANGE 3000, 5000)"}));
  }
  EXPECT_THAT(Query(R"(SELECT column_name, is_identity,
          identity_generation, identity_kind, identity_start_with_counter,
          identity_skip_range_min, identity_skip_range_max
          FROM INFORMATION_SCHEMA.COLUMNS
          where table_name = 't' and column_name = 'id')"),
              IsOkAndHoldsRows(
                  {{"id", "YES", "BY DEFAULT", "BIT_REVERSED_POSITIVE_SEQUENCE",
                    Null<std::string>(), "3000", "5000"}}));
}

TEST_P(IdentityColumnTest, SetDefaultSequenceKindFromNullToValue) {
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
      ALTER DATABASE db
      SET spanner.default_sequence_kind = DEFAULT)"}));
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
      ALTER DATABASE db
      SET spanner.default_sequence_kind = 'bit_reversed_positive')"}));

  } else {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(ALTER DATABASE db SET OPTIONS (
        default_sequence_kind = NULL))"}));
    ZETASQL_ASSERT_OK(UpdateSchema({R"(ALTER DATABASE db SET OPTIONS (
        default_sequence_kind = 'bit_reversed_positive'))"}));
  }
}

TEST_P(IdentityColumnTest, SetDefaultSequenceKindFromValueToNull) {
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
      ALTER DATABASE db
      SET spanner.default_sequence_kind = 'bit_reversed_positive')"}));
    EXPECT_THAT(UpdateSchema({R"(
      ALTER DATABASE db
      SET spanner.default_sequence_kind = DEFAULT)"}),
                StatusIs(absl::StatusCode::kFailedPrecondition,
                         HasSubstr("The default_sequence_kind option may not "
                                   "be unset once set.")));
  } else {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(ALTER DATABASE db SET OPTIONS (
        default_sequence_kind = 'bit_reversed_positive'))"}));
    EXPECT_THAT(UpdateSchema({R"(ALTER DATABASE db SET OPTIONS (
        default_sequence_kind = NULL))"}),
                StatusIs(absl::StatusCode::kFailedPrecondition,
                         HasSubstr("The default_sequence_kind option may not "
                                   "be unset once set.")));
  }
}

TEST_P(IdentityColumnTest, UseDefaultSequenceKindOption) {
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
    ALTER DATABASE db
      SET spanner.default_sequence_kind = 'bit_reversed_positive')",
                            R"(
    CREATE TABLE test_table (
      id BIGINT GENERATED BY DEFAULT AS IDENTITY (START COUNTER WITH 1000),
      non_key_col BIGINT GENERATED BY DEFAULT AS IDENTITY (
        START COUNTER WITH 3000),
      value BIGINT,
      PRIMARY KEY(id)
    ))"}));
    ZETASQL_ASSERT_OK(CommitDml(
        {SqlStatement("INSERT INTO test_table(value) VALUES (1), (2), (3)")}));
    // Check that counters have incremented at least 3 times.
    ASSERT_THAT(Query(R"(
        SELECT spanner.GET_TABLE_COLUMN_IDENTITY_STATE('test_table.id') >= 1003,
               spanner.GET_TABLE_COLUMN_IDENTITY_STATE(
                                    'test_table.non_key_col') >= 3003
              )"),
                IsOkAndHoldsRows({{true, true}}));
  } else {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
    ALTER DATABASE db SET OPTIONS (
      default_sequence_kind = 'bit_reversed_positive'))",
                            R"(
    CREATE TABLE test_table (
      id INT64 GENERATED BY DEFAULT AS IDENTITY (START COUNTER WITH 1000),
      non_key_col INT64 GENERATED BY DEFAULT AS IDENTITY (
        START COUNTER WITH 3000),
      value INT64
    ) PRIMARY KEY(id))"}));
    ZETASQL_ASSERT_OK(CommitDml(
        {SqlStatement("INSERT INTO test_table(value) VALUES (1), (2), (3)")}));
    // Check that counters have incremented at least 3 times.
    ASSERT_THAT(Query(R"(
        SELECT GET_TABLE_COLUMN_IDENTITY_STATE('test_table.id') >= 1003,
               GET_TABLE_COLUMN_IDENTITY_STATE('test_table.non_key_col') >= 3003
              )"),
                IsOkAndHoldsRows({{true, true}}));
  }
}

TEST_P(IdentityColumnTest, NotAllowSetColumnDefault) {
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
    CREATE TABLE test_table (
      id BIGINT GENERATED BY DEFAULT AS IDENTITY (BIT_REVERSED_POSITIVE),
      value BIGINT,
      PRIMARY KEY(id)
    ))"}));
  } else {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
    CREATE TABLE test_table (
      id INT64 GENERATED BY DEFAULT AS IDENTITY (BIT_REVERSED_POSITIVE),
      value INT64
    ) PRIMARY KEY(id))"}));
  }
  EXPECT_THAT(
      UpdateSchema({R"(
    ALTER TABLE test_table ALTER COLUMN id SET DEFAULT (1)
    )"}),
      StatusIs(absl::StatusCode::kInvalidArgument,
               HasSubstr("Cannot alter an identity column `test_table.id` "
                         "to a generated or default column")));
}

TEST_P(IdentityColumnTest, CreateIndexOnIdentityColumn) {
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
    CREATE TABLE test_table (
      id BIGINT GENERATED BY DEFAULT AS IDENTITY (BIT_REVERSED_POSITIVE),
      value BIGINT,
      PRIMARY KEY(id)
    ))",
                            R"(
    CREATE INDEX Index ON test_table(id DESC)
    )"}));
    ZETASQL_ASSERT_OK(CommitDml(
        {SqlStatement("INSERT INTO test_table(value) VALUES (1), (2), (3)")}));
    // Check that counter has incremented at least 3 times.
    ASSERT_THAT(
        Query("SELECT "
              "spanner.GET_TABLE_COLUMN_IDENTITY_STATE('test_table.id') >= 3"),
        IsOkAndHoldsRows({{true}}));
  } else {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
    CREATE TABLE test_table (
      id INT64 GENERATED BY DEFAULT AS IDENTITY (BIT_REVERSED_POSITIVE),
      value INT64
    ) PRIMARY KEY(id))",
                            R"(
    CREATE INDEX Index ON test_table(id DESC)
    )"}));
    ZETASQL_ASSERT_OK(CommitDml(
        {SqlStatement("INSERT INTO test_table(value) VALUES (1), (2), (3)")}));
    // Check that counter has incremented at least 3 times.
    ASSERT_THAT(Query("SELECT "
                      "GET_TABLE_COLUMN_IDENTITY_STATE('test_table.id') >= 3"),
                IsOkAndHoldsRows({{true}}));
  }
}

TEST_P(IdentityColumnTest, IdentityColumnInSystemCatalogSequenceTables) {
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
              ALTER TABLE T
                ADD COLUMN
                  another_id BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY (
                    BIT_REVERSED_POSITIVE START COUNTER WITH 1000))"}));

    // In OSS PG, `pg_sequence` and `pg_sequences` include identity columns'
    // sequences. However, they are internal sequences in Spanner and should not
    // be exposed to users (see more at
    // http://go/spanner-identity-column-design#bookmark=id.uzior5bpphfe)
    EXPECT_THAT(Query(R"(SELECT * FROM pg_catalog.pg_sequence)"),
                IsOkAndHoldsRows({}));

    EXPECT_THAT(Query(R"(SELECT * FROM pg_catalog.pg_sequences)"),
                IsOkAndHoldsRows({}));

  } else {
    GTEST_SKIP() << "This test is only for PG.";
  }
}

TEST_P(IdentityColumnTest, InternalSequenceIsHiddenFromUser) {
  if (GetParam() == database_api::DatabaseDialect::POSTGRESQL) {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
    CREATE TABLE first_table (
      id BIGINT GENERATED BY DEFAULT AS IDENTITY (BIT_REVERSED_POSITIVE),
      value BIGINT,
      PRIMARY KEY(id)
    ))"}));

    // The internal sequence name in Emulator is generated in the form of
    // "_identity_seq_<table_name>__<column_name>" (see
    // SchemaUpdaterImpl::SetColumnDefinition).
    absl::string_view first_table_id_seq_name = "_identity_seq_first_table__id";

    // Creating a table with id column default to the internal sequence of
    // first_table.id is unsuccessful.
    std::string create_sql = absl::Substitute(
        "CREATE TABLE second_table ("
        "  id BIGINT DEFAULT (NEXTVAL('$0')),"
        "  value BIGINT,"
        "  PRIMARY KEY(id)"
        ")",
        first_table_id_seq_name);
    EXPECT_THAT(
        UpdateSchema({create_sql.c_str()}),
        StatusIs(absl::StatusCode::kInvalidArgument,
                 ContainsRegex("Sequence.*(not found|does not exist)")));

    // Creating a table with state column default to the internal sequence of
    // first_table.id is unsuccessful.
    std::string another_create_sql = absl::Substitute(
        "CREATE TABLE third_table ("
        "  state BIGINT DEFAULT (SPANNER.GET_INTERNAL_SEQUENCE_STATE('$0')),"
        "  value BIGINT,"
        "  PRIMARY KEY(state)"
        ")",
        first_table_id_seq_name);
    EXPECT_THAT(
        UpdateSchema({another_create_sql.c_str()}),
        StatusIs(absl::StatusCode::kInvalidArgument,
                 ContainsRegex("Sequence.*(not found|does not exist)")));

    // Altering the internal sequence is unsuccessful.
    std::string alter_sql = absl::Substitute(
        "ALTER SEQUENCE $0 SKIP RANGE 1 1000", first_table_id_seq_name);
    EXPECT_THAT(UpdateSchema({alter_sql.c_str()}),
                StatusIs(absl::StatusCode::kNotFound,
                         HasSubstr("_identity_seq_first_table__id")));

    // Dropping the internal sequence is unsuccessful.
    std::string drop_sql =
        absl::Substitute("DROP SEQUENCE $0", first_table_id_seq_name);
    EXPECT_THAT(UpdateSchema({drop_sql.c_str()}),
                StatusIs(absl::StatusCode::kNotFound,
                         HasSubstr("_identity_seq_first_table__id")));
  } else {
    ZETASQL_ASSERT_OK(UpdateSchema({R"(
    CREATE TABLE first_table (
      id INT64 GENERATED BY DEFAULT AS IDENTITY (BIT_REVERSED_POSITIVE),
      value INT64
    ) PRIMARY KEY(id))"}));

    // The internal sequence name in Emulator is generated in the form of
    // "_identity_seq_<table_name>__<column_name>" (see
    // SchemaUpdaterImpl::SetColumnDefinition).
    absl::string_view first_table_id_seq_name = "_identity_seq_first_table__id";

    // Creating a table with id column default to the internal sequence of
    // first_table.id is unsuccessful.
    std::string create_sql = absl::Substitute(
        "CREATE TABLE second_table ("
        "  id INT64 DEFAULT (GET_NEXT_SEQUENCE_VALUE(SEQUENCE $0)),"
        "  value INT64"
        ") PRIMARY KEY(id)",
        first_table_id_seq_name);
    EXPECT_THAT(UpdateSchema({create_sql.c_str()}),
                StatusIs(absl::StatusCode::kInvalidArgument,
                         HasSubstr(absl::Substitute("Sequence not found: $0",
                                                    first_table_id_seq_name))));

    // Creating a table with state column default to the internal sequence of
    // first_table.id is unsuccessful.
    std::string another_create_sql = absl::Substitute(
        "CREATE TABLE third_table ("
        "  state INT64 DEFAULT (GET_INTERNAL_SEQUENCE_STATE(SEQUENCE $0)),"
        "  value INT64"
        ") PRIMARY KEY(state)",
        first_table_id_seq_name);
    EXPECT_THAT(UpdateSchema({another_create_sql.c_str()}),
                StatusIs(absl::StatusCode::kInvalidArgument,
                         HasSubstr(absl::Substitute("Sequence not found: $0",
                                                    first_table_id_seq_name))));

    // Altering the internal sequence is unsuccessful.
    std::string alter_sql = absl::Substitute(
        "ALTER SEQUENCE $0 SKIP RANGE 1, 1000", first_table_id_seq_name);
    EXPECT_THAT(UpdateSchema({alter_sql.c_str()}),
                StatusIs(absl::StatusCode::kNotFound,
                         HasSubstr("_identity_seq_first_table__id")));

    // Dropping the internal sequence is unsuccessful.
    std::string drop_sql =
        absl::Substitute("DROP SEQUENCE $0", first_table_id_seq_name);
    EXPECT_THAT(UpdateSchema({drop_sql.c_str()}),
                StatusIs(absl::StatusCode::kNotFound,
                         HasSubstr("_identity_seq_first_table__id")));
  }
}

}  // namespace

}  // namespace test
}  // namespace emulator
}  // namespace spanner
}  // namespace google
