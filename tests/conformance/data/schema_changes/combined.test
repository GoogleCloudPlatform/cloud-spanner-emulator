# Duplicate table name.
CREATE TABLE Users (
) PRIMARY KEY();
CREATE TABLE Users (
) PRIMARY KEY();
CREATE TABLE users (
) PRIMARY KEY();
--
ERROR: Duplicate name in schema: Users.
==
# Index names are in the same namespace.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
CREATE NULL_FILTERED INDEX UsersByName ON Users(UserName);
CREATE TABLE UsersByName (
) PRIMARY KEY();
CREATE TABLE usersbyname (
) PRIMARY KEY();
--
ERROR: Duplicate name in schema: UsersByName.
==
# NOT NULL constraint cannot be dropped because it affects indexing of nulls
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
CREATE TABLE Albums (
  UserId INT64 NOT NULL,
  AlbumId INT64 NOT NULL,
  AlbumName STRING(MAX) NOT NULL,
) PRIMARY KEY(UserId, AlbumId),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
CREATE INDEX AlbumsByName ON Albums(AlbumName);
ALTER TABLE Albums ALTER COLUMN AlbumName STRING(MAX);
--
ERROR: Changing NOT NULL constraints on column AlbumName is not allowed because it affects index AlbumsByName.
==
# Interleave within nonexistent table.
CREATE TABLE Albums (
) PRIMARY KEY(),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
--
ERROR: Table not found: Users
==
# Interleave within self, which counts as a nonexistent table.
CREATE TABLE Albums (
) PRIMARY KEY(),
  INTERLEAVE IN PARENT Albums ON DELETE CASCADE;
--
ERROR: Table not found: Albums
==
# Duplicate column name.
CREATE TABLE Users (
  UserName STRING(MAX),
  UserName STRING(MAX),
) PRIMARY KEY();
CREATE TABLE Users (
  UserName STRING(MAX),
  username STRING(MAX),
) PRIMARY KEY();
--
ERROR: Duplicate column name Users.UserName.
==
# Primary key references a nonexistent column.
# --regex
CREATE TABLE Users (
) PRIMARY KEY(UserId);
--
ERROR: [Tt]able Users references nonexistent key column UserId.
==
# Primary key references a column with incorrect case.
# --regex
CREATE TABLE Users (
  UserId INT64 NOT NULL,
) PRIMARY KEY(userid);
--
ERROR: [Tt]able Users references nonexistent key column userid.
==
# Primary key references a column twice.
# --regex
CREATE TABLE Users (
  UserId INT64 NOT NULL,
) PRIMARY KEY(UserId, UserId);
--
ERROR: [Tt]able Users references key column UserId more than once.
==
# Primary key references an ARRAY column.
CREATE TABLE Users (
  UserIds ARRAY<INT64> NOT NULL,
) PRIMARY KEY(UserIds);
--
ERROR: Column Users.UserIds has type ARRAY, but is part of the primary key.
==
# Interleaved table does not reference parent key column.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
) PRIMARY KEY(UserId);
CREATE TABLE Albums (
) PRIMARY KEY(),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
--
ERROR: Table Albums does not reference parent key column UserId.
==
# Interleaved table references parent key column at incorrect position.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
) PRIMARY KEY(UserId);
CREATE TABLE Albums (
  UserId INT64 NOT NULL,
  AlbumId INT64 NOT NULL,
) PRIMARY KEY(AlbumId, UserId),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
--
ERROR: Table Albums references parent key column UserId at incorrect position 1.
==
# Interleaved table references parent key column with incorrect sort order.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
) PRIMARY KEY(UserId);
CREATE TABLE Albums (
  UserId INT64 NOT NULL,
) PRIMARY KEY(UserId DESC),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
--
ERROR: Table Albums references parent key column UserId with incorrect order ASC.
==
# Interleaved table references parent key column with incorrect length.
CREATE TABLE Users (
  UserName STRING(MAX) NOT NULL,
) PRIMARY KEY(UserName);
CREATE TABLE Albums (
  UserName STRING(42) NOT NULL,
) PRIMARY KEY(UserName),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
--
ERROR: Table Albums references parent key column UserName with incorrect length 42 (should be MAX).
==
# Column of type DOUBLE listed as key of a directory table.
CREATE TABLE Users (
  UserId FLOAT64 NOT NULL,
) PRIMARY KEY(UserId);
--
CREATE TABLE Users (
  UserId FLOAT64 NOT NULL,
) PRIMARY KEY(UserId);
==
# Column has invalid length.
CREATE TABLE Users (
  UserName STRING(0),
) PRIMARY KEY();
--
ERROR: Bad length for column Users.UserName: 0 : Allowed length range: [1, 2621440].
==
# ARRAY<STRING> column has invalid length.
CREATE TABLE Users (
  UserName ARRAY<STRING(400000000)>,
) PRIMARY KEY();
--
ERROR: Bad length for column Users.UserName: 400000000 : Allowed length range: [1, 2621440].
==
# Table has too many keys.
CREATE TABLE Users (
  UserId1 INT64 NOT NULL,
  UserId2 INT64 NOT NULL,
  UserId3 INT64 NOT NULL,
  UserId4 INT64 NOT NULL,
  UserId5 INT64 NOT NULL,
  UserId6 INT64 NOT NULL,
) PRIMARY KEY(UserId1, UserId2, UserId3, UserId4, UserId5, UserId6);
CREATE TABLE Albums (
  UserId1 INT64 NOT NULL,
  UserId2 INT64 NOT NULL,
  UserId3 INT64 NOT NULL,
  UserId4 INT64 NOT NULL,
  UserId5 INT64 NOT NULL,
  UserId6 INT64 NOT NULL,
  AlbumId1 INT64 NOT NULL,
  AlbumId2 INT64 NOT NULL,
  AlbumId3 INT64 NOT NULL,
  AlbumId4 INT64 NOT NULL,
  AlbumId5 INT64 NOT NULL,
  AlbumId6 INT64 NOT NULL,
) PRIMARY KEY(UserId1, UserId2, UserId3, UserId4, UserId5, UserId6, AlbumId1, AlbumId2, AlbumId3, AlbumId4, AlbumId5, AlbumId6),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
CREATE TABLE Photos (
  UserId1 INT64 NOT NULL,
  UserId2 INT64 NOT NULL,
  UserId3 INT64 NOT NULL,
  UserId4 INT64 NOT NULL,
  UserId5 INT64 NOT NULL,
  UserId6 INT64 NOT NULL,
  AlbumId1 INT64 NOT NULL,
  AlbumId2 INT64 NOT NULL,
  AlbumId3 INT64 NOT NULL,
  AlbumId4 INT64 NOT NULL,
  AlbumId5 INT64 NOT NULL,
  AlbumId6 INT64 NOT NULL,
  PhotoId1 INT64 NOT NULL,
  PhotoId2 INT64 NOT NULL,
  PhotoId3 INT64 NOT NULL,
  PhotoId4 INT64 NOT NULL,
  PhotoId5 INT64 NOT NULL,
) PRIMARY KEY(UserId1, UserId2, UserId3, UserId4, UserId5, UserId6, AlbumId1, AlbumId2, AlbumId3, AlbumId4, AlbumId5, AlbumId6, PhotoId1, PhotoId2, PhotoId3, PhotoId4, PhotoId5),
  INTERLEAVE IN PARENT Albums ON DELETE CASCADE;
--
ERROR: Table Photos has too many keys (17); the limit is 16.
==
# Third-level table has no columns.
CREATE TABLE Users (
) PRIMARY KEY();
CREATE TABLE Albums (
) PRIMARY KEY(),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
CREATE TABLE Photos (
) PRIMARY KEY(),
  INTERLEAVE IN PARENT Albums ON DELETE CASCADE;
--
ERROR: Table Albums adds no columns and is not a top level table.
==
# Non-primary key column is NOT NULL for a directory table.
CREATE TABLE Users (
  user_info STRING(MAX) NOT NULL,
) PRIMARY KEY();
--
CREATE TABLE Users (
  user_info STRING(MAX) NOT NULL,
) PRIMARY KEY();
==
# Options invalid for the column type
CREATE TABLE Users (
  UserName STRING(MAX) OPTIONS (
    allow_commit_timestamp = true
  ),
) PRIMARY KEY();
--
ERROR: Column Users.UserName has invalid allow_commit_timestamp option.  Option only allowed on TIMESTAMP columns.
==
# Options invalid for the column type if allowed on TIMESTAMP.
CREATE TABLE Users (
  UserName STRING(MAX) OPTIONS (
    allow_commit_timestamp = true
  ),
) PRIMARY KEY();
--
ERROR: Column Users.UserName has invalid allow_commit_timestamp option.  Option only allowed on TIMESTAMP columns.
==
# Child table must match parent key commit timestamp settings #1
CREATE TABLE A (
  Timestamp INT64 NOT NULL OPTIONS (
    allow_commit_timestamp = true
  ),
) PRIMARY KEY(Timestamp);
CREATE TABLE B (
  Timestamp INT64 NOT NULL,
) PRIMARY KEY(Timestamp),
  INTERLEAVE IN PARENT A ON DELETE CASCADE;
--
ERROR: Column A.Timestamp has invalid allow_commit_timestamp option.  Option only allowed on TIMESTAMP columns.
==
# Child table must match parent key commit timestamp settings #2
CREATE TABLE A (
  Timestamp INT64 NOT NULL OPTIONS (
    allow_commit_timestamp = true
  ),
) PRIMARY KEY(Timestamp);
CREATE TABLE B (
  Timestamp INT64 NOT NULL OPTIONS (
    allow_commit_timestamp = false
  ),
) PRIMARY KEY(Timestamp),
  INTERLEAVE IN PARENT A ON DELETE CASCADE;
--
ERROR: Column A.Timestamp has invalid allow_commit_timestamp option.  Option only allowed on TIMESTAMP columns.
==
# Child table must match parent key commit timestamp settings #3
CREATE TABLE A (
  Timestamp INT64 NOT NULL,
) PRIMARY KEY(Timestamp);
CREATE TABLE B (
  Timestamp INT64 NOT NULL OPTIONS (
    allow_commit_timestamp = true
  ),
) PRIMARY KEY(Timestamp),
  INTERLEAVE IN PARENT A ON DELETE CASCADE;
--
ERROR: Column B.Timestamp has invalid allow_commit_timestamp option.  Option only allowed on TIMESTAMP columns.
==
# Child table must match parent key commit timestamp settings #4
CREATE TABLE A (
  Timestamp INT64 NOT NULL OPTIONS (
    allow_commit_timestamp = false
  ),
) PRIMARY KEY(Timestamp);
CREATE TABLE B (
  Timestamp INT64 NOT NULL OPTIONS (
    allow_commit_timestamp = true
  ),
) PRIMARY KEY(Timestamp),
  INTERLEAVE IN PARENT A ON DELETE CASCADE;
--
ERROR: Column A.Timestamp has invalid allow_commit_timestamp option.  Option only allowed on TIMESTAMP columns.
==
# Duplicate index name.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
CREATE NULL_FILTERED INDEX UsersByName ON Users(UserName);
CREATE NULL_FILTERED INDEX UsersByName ON Users(UserName);
CREATE NULL_FILTERED INDEX usersbyname ON Users(UserName);
--
ERROR: Duplicate name in schema: UsersByName.
==
# Table names are in the same namespace.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
CREATE NULL_FILTERED INDEX Users ON Users(UserName);
--
ERROR: Duplicate name in schema: Users.
==
# Index specifies nonexistent table for interleaving.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
) PRIMARY KEY(UserId);
CREATE TABLE Albums (
  UserId INT64 NOT NULL,
  AlbumId INT64 NOT NULL,
  AlbumName STRING(MAX),
) PRIMARY KEY(UserId, AlbumId),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
CREATE NULL_FILTERED INDEX AlbumsByName ON Albums(UserId, AlbumName), INTERLEAVE IN DoesNotExist;
--
ERROR: Cannot interleave index AlbumsByName within nonexistent table DoesNotExist.
==
# Ordering of a parent key component for an interleaved index doesn't match.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
) PRIMARY KEY(UserId);
CREATE TABLE Albums (
  UserId INT64 NOT NULL,
  AlbumId INT64 NOT NULL,
  AlbumName STRING(MAX),
) PRIMARY KEY(UserId, AlbumId),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
CREATE NULL_FILTERED INDEX AlbumsByName ON Albums(UserId DESC, AlbumName), INTERLEAVE IN Users;
--
ERROR: Index AlbumsByName references parent key column UserId with incorrect order ASC.
==
# Index does not specify any key columns.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
) PRIMARY KEY(UserId);
CREATE NULL_FILTERED INDEX UsersByNothing ON Users();
--
ERROR: Index UsersByNothing does not specify any key columns.
==
# Index has too many keys. Note the total number of index keys includes the
# keys of the table being indexed.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserId2 INT64 NOT NULL,
  Data1 INT64,
  Data2 INT64,
  Data3 INT64,
  Data4 INT64,
  Data5 INT64,
  Data6 INT64,
  Data7 INT64,
  Data8 INT64,
  Data9 INT64,
  Data10 INT64,
  Data11 INT64,
  Data12 INT64,
  Data13 INT64,
  Data14 INT64,
  Data15 INT64,
  Data16 INT64,
  Data17 INT64,
) PRIMARY KEY(UserId, UserId2);
CREATE NULL_FILTERED INDEX UsersByData ON Users(Data1, Data2, UserId, Data3, Data4, Data5, Data6, Data7, Data8, Data9, Data10, Data11, Data12, Data13, Data14, Data15);
--
ERROR: Index UsersByData has too many keys (17); the limit is 16.
==
# Index specifies nonexistent key column.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
) PRIMARY KEY(UserId);
CREATE NULL_FILTERED INDEX UsersByName ON Users(UserName);
--
ERROR: Index UsersByName specifies key column UserName which does not exist in the index's base table.
==
# Index specifies key column twice.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
CREATE NULL_FILTERED INDEX UsersByName ON Users(UserName, UserName);
--
ERROR: Index UsersByName specifies key column UserName twice.
==
# Index specifies keys that are not a prefix of the interleaved table.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
) PRIMARY KEY(UserId);
CREATE TABLE Albums (
  UserId INT64 NOT NULL,
  AlbumId INT64 NOT NULL,
  AlbumName STRING(MAX),
) PRIMARY KEY(UserId, AlbumId),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
CREATE NULL_FILTERED INDEX AlbumsByName ON Albums(AlbumName), INTERLEAVE IN Users;
--
ERROR: Index AlbumsByName does not reference index parent key column UserId.
==
# An index on an ARRAY without "DISTINCT_ARRAY_ELEMENT" is an error.
CREATE TABLE Root (
  user_id INT64 NOT NULL,
  vals ARRAY<INT64>,
) PRIMARY KEY(user_id);
CREATE NULL_FILTERED INDEX Index1 ON Root(vals);
--
ERROR: Cannot reference ARRAY vals in the creation of index Index1.
==
# Bad index name because index table collides with index directory name.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
CREATE NULL_FILTERED INDEX Dir_BadIndexName ON Users(UserName);
--
ERROR: Index name not valid: Dir_BadIndexName.
==
# Can't drop a table with interleaved tables.
DROP TABLE DoesNotExist;
CREATE TABLE Users (
) PRIMARY KEY();
CREATE TABLE Albums (
) PRIMARY KEY(),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
CREATE TABLE Photos (
  PhotoId INT64 NOT NULL,
) PRIMARY KEY(PhotoId),
  INTERLEAVE IN PARENT Albums ON DELETE CASCADE;
DROP TABLE Albums;
--
ERROR: Table not found: DoesNotExist
==
# Can't drop a table with an index.
CREATE TABLE Users (
) PRIMARY KEY();
CREATE TABLE Albums (
  AlbumId INT64 NOT NULL,
  AlbumName STRING(MAX),
) PRIMARY KEY(AlbumId),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
CREATE NULL_FILTERED INDEX AlbumsByName ON Albums(AlbumName);
DROP TABLE Albums;
--
ERROR: Cannot drop table Albums with indices: AlbumsByName.
==
CREATE TABLE Users (
) PRIMARY KEY();
CREATE TABLE Albums (
  AlbumId INT64 NOT NULL,
) PRIMARY KEY(AlbumId),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
CREATE TABLE Photos (
  AlbumId INT64 NOT NULL,
  PhotoId INT64 NOT NULL,
  PhotoName STRING(MAX),
) PRIMARY KEY(AlbumId, PhotoId),
  INTERLEAVE IN PARENT Albums ON DELETE CASCADE;
CREATE NULL_FILTERED INDEX PhotosByName ON Photos(AlbumId, PhotoName), INTERLEAVE IN Albums;
DROP TABLE Albums;
--
ERROR: Cannot drop table Albums with interleaved tables: Photos.
==
# Duplicate column name for new column.
CREATE TABLE Users (
  UserName STRING(MAX),
) PRIMARY KEY();
ALTER TABLE Users ADD COLUMN UserName STRING(MAX);
ALTER TABLE Users ADD COLUMN username STRING(MAX);
--
ERROR: Duplicate column name Users.UserName.
==
# Make sure two added columns also fail.
CREATE TABLE Users (
) PRIMARY KEY();
ALTER TABLE Users ADD COLUMN UserName STRING(MAX);
ALTER TABLE Users ADD COLUMN UserName STRING(MAX);
--
ERROR: Duplicate column name Users.UserName.
==
# Duplicate column name for new column (interleave alias version).
CREATE TABLE Users (
) PRIMARY KEY();
CREATE TABLE Albums (
) PRIMARY KEY(),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
ALTER TABLE Users ADD COLUMN albums STRING(MAX);
ALTER TABLE Users ADD COLUMN ALBums STRING(MAX);
--
ERROR: Table Albums adds no columns and is not a top level table.
==
# New column is NOT NULL.
CREATE TABLE Users (
) PRIMARY KEY();
ALTER TABLE Users ADD COLUMN UserName STRING(MAX) NOT NULL;
--
ERROR: Cannot add NOT NULL column Users.UserName to existing table Users.
==
# New column has invalid length.
CREATE TABLE Users (
) PRIMARY KEY();
ALTER TABLE Users ADD COLUMN UserName STRING(0);
--
ERROR: Bad length for column Users.UserName: 0 : Allowed length range: [1, 2621440].
==
# Can't drop columns that don't exist.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
) PRIMARY KEY(UserId);
ALTER TABLE Users DROP COLUMN DoesNotExist;
--
ERROR: Column not found in table Users: DoesNotExist
==
# Can't drop key columns.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
) PRIMARY KEY(UserId);
ALTER TABLE Users DROP COLUMN UserId;
--
ERROR: Cannot drop key column UserId from table Users.
==
# Can't drop key columns from non-directory tables, either.
CREATE TABLE Users (
) PRIMARY KEY();
CREATE TABLE Albums (
  AlbumId INT64 NOT NULL,
) PRIMARY KEY(AlbumId),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
ALTER TABLE Albums DROP COLUMN AlbumId;
--
ERROR: Cannot drop key column AlbumId from table Albums.
==
# Can't drop columns used as index keys.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
CREATE NULL_FILTERED INDEX UsersByName ON Users(UserName);
ALTER TABLE Users DROP COLUMN UserName;
--
ERROR: Cannot drop column UserName from table Users because it is used by index UsersByName.
==
# Can't alter columns that don't exist.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
) PRIMARY KEY(UserId);
ALTER TABLE Users ALTER COLUMN DoesNotExist STRING(MAX);
--
ERROR: Column not found in table Users: DoesNotExist
==
# Altered primary key column is not NOT NULL.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
) PRIMARY KEY(UserId);
ALTER TABLE Users ALTER COLUMN UserId INT64;
--
ERROR: Cannot change key column Users.UserId.
==
# Altered column has invalid length.
CREATE TABLE Users (
  UserName STRING(40),
) PRIMARY KEY();
ALTER TABLE Users ALTER COLUMN UserName STRING(400000000);
--
ERROR: Bad length for column Users.UserName: 400000000 : Allowed length range: [1, 2621440].
==
# Remove NOT NULL from key.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
) PRIMARY KEY(UserId);
ALTER TABLE Users ALTER COLUMN UserId INT64;
--
ERROR: Cannot change key column Users.UserId.
==
# Arrays: decrease inner length of column.
CREATE TABLE Users (
  UserNames ARRAY<STRING(40)>,
) PRIMARY KEY();
ALTER TABLE Users ALTER COLUMN UserNames ARRAY<STRING(20)>;
--
CREATE TABLE Users (
  UserNames ARRAY<STRING(20)>,
) PRIMARY KEY();
==
# Arrays: add inner length to column.
CREATE TABLE Users (
  UserNames ARRAY<STRING(MAX)>,
) PRIMARY KEY();
ALTER TABLE Users ALTER COLUMN UserNames ARRAY<STRING(40)>;
--
CREATE TABLE Users (
  UserNames ARRAY<STRING(40)>,
) PRIMARY KEY();
==
# Arrays: change type of column other than STRING -> BYTES.
CREATE TABLE Users (
  UserNames ARRAY<BYTES(MAX)>,
) PRIMARY KEY();
ALTER TABLE Users ALTER COLUMN UserNames ARRAY<STRING(MAX)>;
--
CREATE TABLE Users (
  UserNames ARRAY<STRING(MAX)>,
) PRIMARY KEY();
==
# Arrays: change subtype of column STRING -> BYTES, but without length
# adjustment.
CREATE TABLE Users (
  UserNames ARRAY<STRING(20)>,
) PRIMARY KEY();
ALTER TABLE Users ALTER COLUMN UserNames ARRAY<BYTES(79)>;
--
CREATE TABLE Users (
  UserNames ARRAY<BYTES(79)>,
) PRIMARY KEY();
==
# SET ON DELETE requires an interleaved table.
CREATE TABLE Users (
  UserId STRING(MAX) NOT NULL,
) PRIMARY KEY(UserId);
ALTER TABLE Users SET ON DELETE CASCADE;
--
ERROR: Cannot SET ON DELETE on table Users that does not have an INTERLEAVE clause.
==
# Even an implicitly-interleaved table is insufficient.
CREATE TABLE Users (
  UserId STRING(MAX) NOT NULL,
) PRIMARY KEY(UserId);
ALTER TABLE Users SET ON DELETE CASCADE;
--
ERROR: Cannot SET ON DELETE on table Users that does not have an INTERLEAVE clause.
==
# Test that the long-running schema changes do not work for arrays.
# Arrays: Cannot add NOT NULL.
CREATE TABLE T (
  C ARRAY<STRING(MAX)>,
) PRIMARY KEY();
ALTER TABLE T ALTER COLUMN C ARRAY<STRING(MAX)> NOT NULL;
--
CREATE TABLE T (
  C ARRAY<STRING(MAX)> NOT NULL,
) PRIMARY KEY();
==
# Arrays: Cannot decrease length.
CREATE TABLE T (
  C ARRAY<STRING(40)>,
) PRIMARY KEY();
ALTER TABLE T ALTER COLUMN C ARRAY<STRING(20)>;
--
CREATE TABLE T (
  C ARRAY<STRING(20)>,
) PRIMARY KEY();
==
# Arrays: Cannot go from BYTES to STRING.
CREATE TABLE T (
  C ARRAY<BYTES(MAX)>,
) PRIMARY KEY();
ALTER TABLE T ALTER COLUMN C ARRAY<STRING(MAX)>;
--
CREATE TABLE T (
  C ARRAY<STRING(MAX)>,
) PRIMARY KEY();
==
# Attempt to name a secondary index PRIMARY_KEY.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
CREATE INDEX PRIMARY_KEY ON Users(UserName);
--
ERROR: Cannot use reserved name PRIMARY_KEY for a secondary index
==
# Attempt to name a secondary index Primary_Key.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
CREATE INDEX Primary_Key ON Users(UserName);
--
ERROR: Cannot use reserved name PRIMARY_KEY for a secondary index
==
# Attempt to make a nullable primary key column not null.
CREATE TABLE Users (
  UserId INT64,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
ALTER TABLE Users ALTER COLUMN UserId INT64 NOT NULL;
--
ERROR: Cannot change key column Users.UserId.
==
# Attempt to make a nullable non-key column with an index not null.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
CREATE INDEX UsersByUserName ON Users(UserName);
ALTER TABLE Users ALTER COLUMN UserName STRING(MAX) NOT NULL;
--
ERROR: Changing NOT NULL constraints on column UserName is not allowed because it affects index UsersByUserName.
==
# Attempt to make a nullable primary key column not null.
CREATE TABLE Users (
  UserId INT64,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
ALTER TABLE Users ALTER COLUMN UserId INT64 NOT NULL;
--
ERROR: Cannot change key column Users.UserId.
==
# Attempt to make a nullable non-key column with an index not null.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
CREATE INDEX UsersByUserName ON Users(UserName);
ALTER TABLE Users ALTER COLUMN UserName STRING(MAX) NOT NULL;
--
ERROR: Changing NOT NULL constraints on column UserName is not allowed because it affects index UsersByUserName.
==
# Attempt to make reduce the size of an ARRAY subtype.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName ARRAY<STRING(MAX)>,
) PRIMARY KEY(UserId);
ALTER TABLE Users ALTER COLUMN UserName ARRAY<STRING(1)>;
--
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName ARRAY<STRING(1)>,
) PRIMARY KEY(UserId);
==
# Alter a directory table that is tentatively being dropped.
CREATE TABLE dir1 (
  k INT64 NOT NULL,
  v STRING(1),
) PRIMARY KEY(k);
DROP TABLE dir1;
ALTER TABLE dir1 ADD COLUMN v2 STRING(MAX);
--
ERROR: Table not found: dir1
==
# Alter a column of a directory table that is tentatively being dropped.
CREATE TABLE dir1 (
  k INT64 NOT NULL,
  v STRING(1),
) PRIMARY KEY(k);
DROP TABLE dir1;
ALTER TABLE dir1 ALTER COLUMN v STRING(2);
--
ERROR: Table not found: dir1
==
# Create an index on a directory table that is tentatively being dropped.
CREATE TABLE dir1 (
  k INT64 NOT NULL,
  v STRING(1),
) PRIMARY KEY(k);
DROP TABLE dir1;
CREATE INDEX dir1IndexOnC ON dir1(v);
--
ERROR: Table not found: dir1
==
# Create interleaved table in directory table that is tentatively being dropped.
CREATE TABLE dir1 (
  k INT64 NOT NULL,
  v STRING(1),
) PRIMARY KEY(k);
DROP TABLE dir1;
CREATE TABLE tbl (
  k INT64 NOT NULL,
  v2 INT64,
) PRIMARY KEY(k),
  INTERLEAVE IN PARENT dir1 ON DELETE CASCADE;
--
ERROR: Table not found: dir1
==
# Directory table with two non-key columns.
CREATE TABLE Users (
  UserId INT64,
  Name STRING(MAX),
) PRIMARY KEY();
--
CREATE TABLE Users (
  UserId INT64,
  Name STRING(MAX),
) PRIMARY KEY();
==
# Directory table with two key columns and a non-key column.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  Name STRING(MAX) NOT NULL,
  Notes STRING(MAX),
) PRIMARY KEY(UserId, Name);
--
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  Name STRING(MAX) NOT NULL,
  Notes STRING(MAX),
) PRIMARY KEY(UserId, Name);
==
# Directory table with a key column and two non-key columns.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  Name STRING(MAX),
  Notes STRING(MAX),
) PRIMARY KEY(UserId);
--
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  Name STRING(MAX),
  Notes STRING(MAX),
) PRIMARY KEY(UserId);
==
# Top-level tables are allowed to have DOUBLE key parts, as opposed to directory
# tables.
CREATE TABLE Users (
  UserId STRING(MAX) NOT NULL,
) PRIMARY KEY(UserId);
CREATE TABLE Albums (
  UserId STRING(MAX) NOT NULL,
  AlbumId FLOAT64 NOT NULL,
) PRIMARY KEY(UserId, AlbumId),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
--
CREATE TABLE Users (
  UserId STRING(MAX) NOT NULL,
) PRIMARY KEY(UserId);
CREATE TABLE Albums (
  UserId STRING(MAX) NOT NULL,
  AlbumId FLOAT64 NOT NULL,
) PRIMARY KEY(UserId, AlbumId),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
==
# Interleaved table with no columns.
CREATE TABLE Users (
) PRIMARY KEY();
CREATE TABLE Albums (
) PRIMARY KEY(),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
--
ERROR: Table Albums adds no columns and is not a top level table.
==
# Interleaved table with key and non-key columns.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
) PRIMARY KEY(UserId);
CREATE TABLE Albums (
  UserId INT64 NOT NULL,
  AlbumId INT64 NOT NULL,
  Name STRING(1024),
  Description STRING(1024),
) PRIMARY KEY(UserId, AlbumId),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
--
CREATE TABLE Users (
  UserId INT64 NOT NULL,
) PRIMARY KEY(UserId);
CREATE TABLE Albums (
  UserId INT64 NOT NULL,
  AlbumId INT64 NOT NULL,
  Name STRING(1024),
  Description STRING(1024),
) PRIMARY KEY(UserId, AlbumId),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
==
# Third-level interleaved table.
CREATE TABLE Users (
) PRIMARY KEY();
CREATE TABLE Albums (
) PRIMARY KEY(),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
CREATE TABLE Photos (
  PhotoId INT64 NOT NULL,
) PRIMARY KEY(PhotoId),
  INTERLEAVE IN PARENT Albums ON DELETE CASCADE;
--
ERROR: Table Albums adds no columns and is not a top level table.
==
# Date columns.
CREATE TABLE T (
  DKey DATE NOT NULL,
  DValue DATE,
) PRIMARY KEY(DKey);
--
CREATE TABLE T (
  DKey DATE NOT NULL,
  DValue DATE,
) PRIMARY KEY(DKey);
==
# Non-primary-key column is NOT NULL.
CREATE TABLE Users (
  UserName STRING(MAX) NOT NULL,
) PRIMARY KEY();
--
CREATE TABLE Users (
  UserName STRING(MAX) NOT NULL,
) PRIMARY KEY();
==
# Global index on top-level NULLable column. Corresponding key part is marked
# as "nullable"
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
CREATE INDEX UsersByName ON Users(UserName);
--
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
CREATE INDEX UsersByName ON Users(UserName);
==
# Local index on top-level NOT NULLable column. Corresponding key part is not
# marked as "nullable"
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
CREATE TABLE Albums (
  UserId INT64 NOT NULL,
  AlbumId INT64 NOT NULL,
  AlbumName STRING(MAX) NOT NULL,
) PRIMARY KEY(UserId, AlbumId),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
CREATE INDEX AlbumsByName ON Albums(UserId, AlbumName), INTERLEAVE IN Users;
--
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
CREATE TABLE Albums (
  UserId INT64 NOT NULL,
  AlbumId INT64 NOT NULL,
  AlbumName STRING(MAX) NOT NULL,
) PRIMARY KEY(UserId, AlbumId),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
CREATE INDEX AlbumsByName ON Albums(UserId, AlbumName), INTERLEAVE IN Users;
==
# Basic global index.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
CREATE NULL_FILTERED INDEX UsersByName ON Users(UserName);
--
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
CREATE NULL_FILTERED INDEX UsersByName ON Users(UserName);
==
# Basic interleaved index.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
) PRIMARY KEY(UserId);
CREATE TABLE Albums (
  UserId INT64 NOT NULL,
  AlbumId INT64 NOT NULL,
  AlbumName STRING(MAX),
) PRIMARY KEY(UserId, AlbumId),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
CREATE NULL_FILTERED INDEX LocalAlbumsByName ON Albums(UserId, AlbumName DESC), INTERLEAVE IN Users;
--
CREATE TABLE Users (
  UserId INT64 NOT NULL,
) PRIMARY KEY(UserId);
CREATE TABLE Albums (
  UserId INT64 NOT NULL,
  AlbumId INT64 NOT NULL,
  AlbumName STRING(MAX),
) PRIMARY KEY(UserId, AlbumId),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
CREATE NULL_FILTERED INDEX LocalAlbumsByName ON Albums(UserId, AlbumName DESC), INTERLEAVE IN Users;
==
# Indices using ASC and DESC.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
CREATE NULL_FILTERED INDEX UsersDesc ON Users(UserName DESC);
CREATE NULL_FILTERED INDEX UsersAsc ON Users(UserName);
--
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
CREATE NULL_FILTERED INDEX UsersAsc ON Users(UserName);
CREATE NULL_FILTERED INDEX UsersDesc ON Users(UserName DESC);
==
# Create a unique index.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
CREATE UNIQUE NULL_FILTERED INDEX UsersByName ON Users(UserName);
--
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
CREATE UNIQUE NULL_FILTERED INDEX UsersByName ON Users(UserName);
==
# Index specifies keys that are a prefix of the keys of the indexed table.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
) PRIMARY KEY(UserId);
CREATE TABLE Albums (
  UserId INT64 NOT NULL,
  AlbumId INT64 NOT NULL,
) PRIMARY KEY(UserId, AlbumId),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
CREATE NULL_FILTERED INDEX AlbumsByUser ON Albums(UserId);
--
CREATE TABLE Users (
  UserId INT64 NOT NULL,
) PRIMARY KEY(UserId);
CREATE TABLE Albums (
  UserId INT64 NOT NULL,
  AlbumId INT64 NOT NULL,
) PRIMARY KEY(UserId, AlbumId),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
CREATE NULL_FILTERED INDEX AlbumsByUser ON Albums(UserId);
==
# Child table matches parent key commit timestamp settings #1
CREATE TABLE A (
  Timestamp INT64 NOT NULL OPTIONS (
    allow_commit_timestamp = true
  ),
) PRIMARY KEY(Timestamp);
CREATE TABLE B (
  Timestamp INT64 NOT NULL OPTIONS (
    allow_commit_timestamp = true
  ),
) PRIMARY KEY(Timestamp),
  INTERLEAVE IN PARENT A ON DELETE CASCADE;
--
ERROR: Column A.Timestamp has invalid allow_commit_timestamp option.  Option only allowed on TIMESTAMP columns.
==
# Child table matches parent key commit timestamp settings #2
CREATE TABLE A (
  Timestamp INT64 NOT NULL OPTIONS (
    allow_commit_timestamp = false
  ),
) PRIMARY KEY(Timestamp);
CREATE TABLE B (
  Timestamp INT64 NOT NULL OPTIONS (
    allow_commit_timestamp = false
  ),
) PRIMARY KEY(Timestamp),
  INTERLEAVE IN PARENT A ON DELETE CASCADE;
--
ERROR: Column A.Timestamp has invalid allow_commit_timestamp option.  Option only allowed on TIMESTAMP columns.
==
# Child table matches parent key commit timestamp settings #3
CREATE TABLE A (
  Timestamp INT64 NOT NULL,
) PRIMARY KEY(Timestamp);
CREATE TABLE B (
  Timestamp INT64 NOT NULL OPTIONS (
    allow_commit_timestamp = false
  ),
) PRIMARY KEY(Timestamp),
  INTERLEAVE IN PARENT A ON DELETE CASCADE;
--
ERROR: Column B.Timestamp has invalid allow_commit_timestamp option.  Option only allowed on TIMESTAMP columns.
==
# Child table matches parent key commit timestamp settings #4
CREATE TABLE A (
  Timestamp INT64 NOT NULL OPTIONS (
    allow_commit_timestamp = false
  ),
) PRIMARY KEY(Timestamp);
CREATE TABLE B (
  Timestamp INT64 NOT NULL,
) PRIMARY KEY(Timestamp),
  INTERLEAVE IN PARENT A ON DELETE CASCADE;
--
ERROR: Column A.Timestamp has invalid allow_commit_timestamp option.  Option only allowed on TIMESTAMP columns.
==
CREATE TABLE T(
  A INT64,
  B TIMESTAMP NOT NULL
) PRIMARY KEY (A);
ALTER TABLE T ALTER COLUMN B SET OPTIONS(allow_commit_timestamp=true);
--
CREATE TABLE T (
  A INT64,
  B TIMESTAMP NOT NULL OPTIONS (
    allow_commit_timestamp = true
  ),
) PRIMARY KEY(A);
==
# Basic drop table.
CREATE TABLE Users (
) PRIMARY KEY();
CREATE TABLE Albums (
) PRIMARY KEY(),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
DROP TABLE Albums;
--
ERROR: Table Albums adds no columns and is not a top level table.
==
# Basic drop index.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
CREATE NULL_FILTERED INDEX UsersByName ON Users(UserName);
DROP INDEX UsersByName;
--
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
==
# Basic add column.
CREATE TABLE Users (
) PRIMARY KEY();
ALTER TABLE Users ADD COLUMN NewColumn INT64;
--
CREATE TABLE Users (
  NewColumn INT64,
) PRIMARY KEY();
==
# Basic drop column.
CREATE TABLE Users (
  OldColumn INT64,
) PRIMARY KEY();
ALTER TABLE Users DROP COLUMN OldColumn;
--
CREATE TABLE Users (
) PRIMARY KEY();
==
# Increase length to MAX.
CREATE TABLE Users (
  UserName STRING(20),
) PRIMARY KEY();
ALTER TABLE Users ALTER COLUMN UserName STRING(MAX);
--
CREATE TABLE Users (
  UserName STRING(MAX),
) PRIMARY KEY();
==
# Arrays: increase length to MAX.
CREATE TABLE Users (
  UserNames ARRAY<STRING(20)>,
) PRIMARY KEY();
ALTER TABLE Users ALTER COLUMN UserNames ARRAY<STRING(MAX)>;
--
CREATE TABLE Users (
  UserNames ARRAY<STRING(MAX)>,
) PRIMARY KEY();
==
CREATE TABLE Users (
  UserName ARRAY<STRING(400000)>,
) PRIMARY KEY();
--
CREATE TABLE Users (
  UserName ARRAY<STRING(400000)>,
) PRIMARY KEY();
==
# Change STRING to BYTES.
CREATE TABLE Users (
  UserName STRING(20),
) PRIMARY KEY();
ALTER TABLE Users ALTER COLUMN UserName BYTES(80);
--
CREATE TABLE Users (
  UserName BYTES(80),
) PRIMARY KEY();
==
# Arrays: change STRING to BYTES.
CREATE TABLE Users (
  UserNames ARRAY<STRING(20)>,
) PRIMARY KEY();
ALTER TABLE Users ALTER COLUMN UserNames ARRAY<BYTES(80)>;
--
CREATE TABLE Users (
  UserNames ARRAY<BYTES(80)>,
) PRIMARY KEY();
==
# Change STRING(MAX) to BYTES(MAX).
CREATE TABLE Users (
  UserName STRING(MAX),
) PRIMARY KEY();
ALTER TABLE Users ALTER COLUMN UserName BYTES(MAX);
--
CREATE TABLE Users (
  UserName BYTES(MAX),
) PRIMARY KEY();
==
# Arrays: change STRING(MAX) to BYTES(MAX).
CREATE TABLE Users (
  UserNames ARRAY<STRING(MAX)>,
) PRIMARY KEY();
ALTER TABLE Users ALTER COLUMN UserNames ARRAY<BYTES(MAX)>;
--
CREATE TABLE Users (
  UserNames ARRAY<BYTES(MAX)>,
) PRIMARY KEY();
==
# Increase length of key column.
CREATE TABLE Users (
  UserId STRING(20) NOT NULL,
) PRIMARY KEY(UserId);
ALTER TABLE Users ALTER COLUMN UserId STRING(40) NOT NULL;
--
CREATE TABLE Users (
  UserId STRING(40) NOT NULL,
) PRIMARY KEY(UserId);
==
# Change STRING key column to BYTES.
CREATE TABLE Users (
  UserId STRING(MAX) NOT NULL,
) PRIMARY KEY(UserId);
ALTER TABLE Users ALTER COLUMN UserId BYTES(MAX) NOT NULL;
--
CREATE TABLE Users (
  UserId BYTES(MAX) NOT NULL,
) PRIMARY KEY(UserId);
==
# Interleaved table with implicit ON DELETE NO ACTION.
CREATE TABLE Users (
) PRIMARY KEY();
CREATE TABLE Albums (
) PRIMARY KEY(),
  INTERLEAVE IN PARENT Users ON DELETE NO ACTION;
--
ERROR: Table Albums adds no columns and is not a top level table.
==
# Interleaved table with explicit ON DELETE NO ACTION.
CREATE TABLE Users (
) PRIMARY KEY();
CREATE TABLE Albums (
) PRIMARY KEY(),
  INTERLEAVE IN PARENT Users ON DELETE NO ACTION;
--
ERROR: Table Albums adds no columns and is not a top level table.
==
# Interleaved table with ON DELETE NO ACTION allowed outside strict mode.
CREATE TABLE Users (
) PRIMARY KEY();
CREATE TABLE Albums (
) PRIMARY KEY(),
  INTERLEAVE IN PARENT Users ON DELETE NO ACTION;
--
ERROR: Table Albums adds no columns and is not a top level table.
==
# Interleaved table altered to ON DELETE NO ACTION.
CREATE TABLE Users (
) PRIMARY KEY();
CREATE TABLE Albums (
) PRIMARY KEY(),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
ALTER TABLE Albums SET ON DELETE NO ACTION;
--
ERROR: Table Albums adds no columns and is not a top level table.
==
# Attempt to make a nullable column not null.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
ALTER TABLE Users ALTER COLUMN UserName STRING(MAX) NOT NULL;
--
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX) NOT NULL,
) PRIMARY KEY(UserId);
==
# Attempt to make a nullable column not null.
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX),
) PRIMARY KEY(UserId);
ALTER TABLE Users ALTER COLUMN UserName STRING(MAX) NOT NULL;
--
CREATE TABLE Users (
  UserId INT64 NOT NULL,
  UserName STRING(MAX) NOT NULL,
) PRIMARY KEY(UserId);
==
# Interleaved table altered to ON DELETE CASCADE.  No-op, but legal.
CREATE TABLE Users (
) PRIMARY KEY();
CREATE TABLE Albums (
) PRIMARY KEY(),
  INTERLEAVE IN PARENT Users ON DELETE CASCADE;
ALTER TABLE Albums SET ON DELETE CASCADE;
--
ERROR: Table Albums adds no columns and is not a top level table.
==
# Check constraint tests for async replication
# Create table without check constraint as reference.
CREATE TABLE T (
  A INT64,
) PRIMARY KEY(A);
--
CREATE TABLE T (
  A INT64,
) PRIMARY KEY(A);
