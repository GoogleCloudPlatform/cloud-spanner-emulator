diff --git a/zetasql/analyzer/BUILD b/zetasql/analyzer/BUILD
index b88b3aa..df9d6ea 100644
--- a/zetasql/analyzer/BUILD
+++ b/zetasql/analyzer/BUILD
@@ -21,1 +21,1 @@
-    default_visibility = ["//zetasql/base:zetasql_implementation"],
+    default_visibility = ["//visibility:public"],
diff --git a/zetasql/base/BUILD b/zetasql/base/BUILD
index 8528859..2d04ac1 100644
--- a/zetasql/base/BUILD
+++ b/zetasql/base/BUILD
@@ -16,7 +16,7 @@
 
 licenses(["notice"])
 
-package(default_visibility = [":zetasql_implementation"])
+package(default_visibility = ["//visibility:public"])
 
 package_group(
     name = "zetasql_implementation",
diff --git a/zetasql/base/testing/BUILD b/zetasql/base/testing/BUILD
index b88b3aa..df9d6ea 100644
--- a/zetasql/base/testing/BUILD
+++ b/zetasql/base/testing/BUILD
@@ -16,7 +16,7 @@
 
 licenses(["notice"])
 
-package(default_visibility = ["//zetasql/base:zetasql_implementation"])
+package(default_visibility = ["//visibility:public"])
 
 # A drop in replacement for gtest_main that parsers absl flags
 cc_library(
diff --git a/zetasql/common/BUILD b/zetasql/common/BUILD
index b88b3aa..df9d6ea 100644
--- a/zetasql/common/BUILD
+++ b/zetasql/common/BUILD
@@ -15,7 +15,7 @@

 package(
-    default_visibility = ["//zetasql/base:zetasql_implementation"],
+    default_visibility = ["//visibility:public"],
     features = ["parse_headers"],
 )

 cc_library(
diff --git a/zetasql/common/internal_value.h b/zetasql/common/internal_value.h
index 9d91e28..38e654c 100644
--- a/zetasql/common/internal_value.h
+++ b/zetasql/common/internal_value.h
@@ -105,7 +105,7 @@ class InternalValue {
   static std::string FormatInternal(const Value& x,
                                     bool include_array_ordereness
   ) {
-    return x.FormatInternal({
-        .force_type_at_top_level = true,
+    return x.FormatInternal(Type::FormatValueContentOptions{
+        .force_type_at_top_level = true,
         .include_array_ordereness = include_array_ordereness,
         .indent = 0,
     });
   }
diff --git a/zetasql/parser/BUILD b/zetasql/parser/BUILD
index b88b3aa..df9d6ea 100644
--- a/zetasql/parser/BUILD
+++ b/zetasql/parser/BUILD
@@ -23,1 +23,1 @@
-    default_visibility = ["//zetasql/base:zetasql_implementation"],
+    default_visibility = ["//visibility:public"],
diff --git a/zetasql/public/types/BUILD b/zetasql/public/types/BUILD
index 235a1ce..3e5b70a 100644
--- a/zetasql/public/types/BUILD
+++ b/zetasql/public/types/BUILD
@@ -17,1 +17,1 @@
-package(default_visibility = ["//zetasql/base:zetasql_implementation"])
+package(default_visibility = ["//visibility:public"])
diff --git a/zetasql/public/types/type.h b/zetasql/public/types/type.h
index 235a1ce..3e5b70a 100644
--- a/zetasql/public/types/type.h
+++ b/zetasql/public/types/type.h
@@ -555,46 +555,7 @@ class Type {
     // error.
     std::optional<int64_t> file_descriptor_sets_max_size_bytes = std::nullopt;
   };
-
- protected:
-  // Types can only be created and destroyed by TypeFactory.
-  Type(const TypeFactory* factory, TypeKind kind);
-  virtual ~Type();
-
-  bool EqualsImpl(const Type* other_type, bool equivalent) const {
-    if (this == other_type) {
-      return true;
-    }
-    if (kind() != other_type->kind()) {
-      return false;
-    }
-    return EqualsForSameKind(other_type, equivalent);
-  }
-
-  // Hashes the type. Hash is generated based on a type's kind and (if type is
-  // not built-in simple type) on a type's parameter.
-  absl::HashState Hash(absl::HashState state) const;
-
-  // Hashes the type's parameter of non-simple (parameterized) types. Simple
-  // built-in types should not update the hash state.
-  virtual absl::HashState HashTypeParameter(absl::HashState state) const = 0;
-
-  // Internal implementation for Serialize methods.  This will append
-  // Type information to <type_proto>, so the caller should make sure
-  // that <type_proto> has been initialized properly before invoking.
-  // <options> controls whether FileDescriptors are deep-scanned and
-  // FileDescriptorSets are generated, and also whether there are any limits
-  // placed on the size of the FileDescriptorSets.
-  virtual absl::Status SerializeToProtoAndDistinctFileDescriptorsImpl(
-      const BuildFileDescriptorSetMapOptions& options, TypeProto* type_proto,
-      FileDescriptorSetMap* file_descriptor_set_map) const = 0;
-
-  // Returns estimated size of memory owned by this type. Note: type can never
-  // own another type, only reference (all types are owned by TypeFactory). So,
-  // this function never calls GetEstimatedOwnedMemoryBytesSize for other types
-  // (such as element types of arrays or field types of structs).
-  virtual int64_t GetEstimatedOwnedMemoryBytesSize() const = 0;
-
+  
   // Formatting options that can be provided to FormatValueContent.
   struct FormatValueContentOptions {
     enum class Mode {
@@ -637,6 +598,45 @@ class Type {
     static const int kIndentStep = 2;
   };
 
+ protected:
+  // Types can only be created and destroyed by TypeFactory.
+  Type(const TypeFactory* factory, TypeKind kind);
+  virtual ~Type();
+
+  bool EqualsImpl(const Type* other_type, bool equivalent) const {
+    if (this == other_type) {
+      return true;
+    }
+    if (kind() != other_type->kind()) {
+      return false;
+    }
+    return EqualsForSameKind(other_type, equivalent);
+  }
+
+  // Hashes the type. Hash is generated based on a type's kind and (if type is
+  // not built-in simple type) on a type's parameter.
+  absl::HashState Hash(absl::HashState state) const;
+
+  // Hashes the type's parameter of non-simple (parameterized) types. Simple
+  // built-in types should not update the hash state.
+  virtual absl::HashState HashTypeParameter(absl::HashState state) const = 0;
+
+  // Internal implementation for Serialize methods.  This will append
+  // Type information to <type_proto>, so the caller should make sure
+  // that <type_proto> has been initialized properly before invoking.
+  // <options> controls whether FileDescriptors are deep-scanned and
+  // FileDescriptorSets are generated, and also whether there are any limits
+  // placed on the size of the FileDescriptorSets.
+  virtual absl::Status SerializeToProtoAndDistinctFileDescriptorsImpl(
+      const BuildFileDescriptorSetMapOptions& options, TypeProto* type_proto,
+      FileDescriptorSetMap* file_descriptor_set_map) const = 0;
+
+  // Returns estimated size of memory owned by this type. Note: type can never
+  // own another type, only reference (all types are owned by TypeFactory). So,
+  // this function never calls GetEstimatedOwnedMemoryBytesSize for other types
+  // (such as element types of arrays or field types of structs).
+  virtual int64_t GetEstimatedOwnedMemoryBytesSize() const = 0;
+
   // List of DebugStringImpl outputs. Used to serve as a stack in
   // DebugStringImpl to protect from stack overflows.
   // Note: SWIG will fail to process this file if we remove a white space
diff --git a/zetasql/public/value.cc b/zetasql/public/value.cc
index 50deb34..2070935 100644
--- a/zetasql/public/value.cc
+++ b/zetasql/public/value.cc
@@ -909,7 +909,7 @@ std::string Value::DebugString(bool verbose) const {
 
 // Format will wrap arrays and structs.
 std::string Value::Format(bool print_top_level_type) const {
-  return FormatInternal(
+  return FormatInternal(Type::FormatValueContentOptions
       {.force_type_at_top_level = print_top_level_type, .indent = 0});
 }
 
@@ -1169,7 +1169,7 @@ std::string Value::FormatInternal(
     std::vector<std::string> element_strings(elements().size());
     for (int i = 0; i < elements().size(); ++i) {
       element_strings[i] =
-          elements()[i].FormatInternal(options.IncreaseIndent());
+          elements()[i].FormatInternal(Type::FormatValueContentOptions{options.IncreaseIndent()});
     }
     // Sanitize any '$' characters before creating substitution template. "$$"
     // is replaced by "$" in the output from absl::Substitute.
@@ -1211,7 +1211,7 @@ std::string Value::FormatInternal(
     const StructType* struct_type = type()->AsStruct();
     std::vector<std::string> field_strings(struct_type->num_fields());
     for (int i = 0; i < struct_type->num_fields(); i++) {
-      field_strings[i] = fields()[i].FormatInternal(options.IncreaseIndent());
+      field_strings[i] = fields()[i].FormatInternal(Type::FormatValueContentOptions{options.IncreaseIndent()});
     }
     // Sanitize any '$' characters before creating substitution template. "$$"
     // is replaced by "$" in the output from absl::Substitute.
@@ -1257,9 +1257,9 @@ std::string Value::FormatInternal(
     }
     std::vector<std::string> boundaries_strings;
     boundaries_strings.push_back(
-        start().FormatInternal(options.IncreaseIndent()));
+        start().FormatInternal(Type::FormatValueContentOptions{options.IncreaseIndent()}));
     boundaries_strings.push_back(
-        end().FormatInternal(options.IncreaseIndent()));
+        end().FormatInternal(Type::FormatValueContentOptions{options.IncreaseIndent()}));
     // Sanitize any '$' characters before creating substitution template. "$$"
     // is replaced by "$" in the output from absl::Substitute.
     std::string templ =
diff --git a/zetasql/analyzer/name_scope.cc b/zetasql/analyzer/name_scope.cc
index 9507aea..de75f25 100644
--- a/zetasql/analyzer/name_scope.cc
+++ b/zetasql/analyzer/name_scope.cc
@@ -1458,7 +1458,8 @@ NameList::AddRangeVariableInWrappingNameList(
   // variables, including for value tables, so we use `flatten_to_table`
   // which drops range variables.
   ZETASQL_RETURN_IF_ERROR(range_variable_name_list->MergeFrom(
-      *original_name_list, ast_location, {.flatten_to_table = true}));
+      *original_name_list, ast_location,
+      MergeOptions{.flatten_to_table = true}));

   auto wrapper_name_list = std::make_shared<NameList>();
   ZETASQL_RETURN_IF_ERROR(
diff --git a/zetasql/analyzer/resolver_query.cc b/zetasql/analyzer/resolver_query.cc
index 0eb93be..a15598f 100644
--- a/zetasql/analyzer/resolver_query.cc
+++ b/zetasql/analyzer/resolver_query.cc
@@ -7478,9 +7478,9 @@ absl::Status Resolver::ResolveTableSubquery(
       // If the value table has an existing range variable, then it has to be
       // renamed to the new name.
       auto new_name_list = std::make_shared<NameList>();
-      ZETASQL_RETURN_IF_ERROR(
-          new_name_list->MergeFrom(*subquery_name_list, table_ref,
-                                   {.rename_value_table_to_name = &alias}));
+      ZETASQL_RETURN_IF_ERROR(new_name_list->MergeFrom(
+          *subquery_name_list, table_ref,
+          NameList::MergeOptions{.rename_value_table_to_name = &alias}));
       *output_name_list = new_name_list;
     } else {
       // If the value table was anonymous and didn't have an existing range
@@ -7493,8 +7493,9 @@ absl::Status Resolver::ResolveTableSubquery(
     // to drop existing range variables and convert value tables to columns,
     // and then make the new range variables pointing at the remaining columns.
     auto new_name_list = std::make_shared<NameList>();
-    ZETASQL_RETURN_IF_ERROR(new_name_list->MergeFrom(*subquery_name_list, table_ref,
-                                             {.flatten_to_table = true}));
+    ZETASQL_RETURN_IF_ERROR(new_name_list->MergeFrom(
+        *subquery_name_list, table_ref,
+        NameList::MergeOptions{.flatten_to_table = true}));

     ZETASQL_ASSIGN_OR_RETURN(*output_name_list,
                      NameList::AddRangeVariableInWrappingNameList(
