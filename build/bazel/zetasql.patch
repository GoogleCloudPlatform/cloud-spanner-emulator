diff --git a/zetasql/analyzer/BUILD b/zetasql/analyzer/BUILD
index b88b3aa..df9d6ea 100644
--- a/zetasql/analyzer/BUILD
+++ b/zetasql/analyzer/BUILD
@@ -21,1 +21,1 @@
-    default_visibility = ["//zetasql/base:zetasql_implementation"],
+    default_visibility = ["//visibility:public"],
diff --git a/zetasql/base/BUILD b/zetasql/base/BUILD
index 8528859..2d04ac1 100644
--- a/zetasql/base/BUILD
+++ b/zetasql/base/BUILD
@@ -16,7 +16,7 @@
 
 licenses(["notice"])
 
-package(default_visibility = [":zetasql_implementation"])
+package(default_visibility = ["//visibility:public"])
 
 package_group(
     name = "zetasql_implementation",
diff --git a/zetasql/base/testing/BUILD b/zetasql/base/testing/BUILD
index b88b3aa..df9d6ea 100644
--- a/zetasql/base/testing/BUILD
+++ b/zetasql/base/testing/BUILD
@@ -16,7 +16,7 @@
 
 licenses(["notice"])
 
-package(default_visibility = ["//zetasql/base:zetasql_implementation"])
+package(default_visibility = ["//visibility:public"])
 
 # A drop in replacement for gtest_main that parsers absl flags
 cc_library(
diff --git a/zetasql/common/BUILD b/zetasql/common/BUILD
index b88b3aa..df9d6ea 100644
--- a/zetasql/common/BUILD
+++ b/zetasql/common/BUILD
@@ -15,7 +15,7 @@

 package(
-    default_visibility = ["//zetasql/base:zetasql_implementation"],
+    default_visibility = ["//visibility:public"],
     features = ["parse_headers"],
 )

 cc_library(
diff --git a/zetasql/common/internal_value.h b/zetasql/common/internal_value.h
index 9d91e28..38e654c 100644
--- a/zetasql/common/internal_value.h
+++ b/zetasql/common/internal_value.h
@@ -105,7 +105,7 @@ class InternalValue {
   static std::string FormatInternal(const Value& x,
                                     bool include_array_ordereness
   ) {
-    return x.FormatInternal({
-        .force_type_at_top_level = true,
+    return x.FormatInternal(Type::FormatValueContentOptions{
+        .force_type_at_top_level = true,
         .include_array_ordereness = include_array_ordereness,
         .indent = 0,
     });
   }
diff --git a/zetasql/parser/BUILD b/zetasql/parser/BUILD
index b88b3aa..df9d6ea 100644
--- a/zetasql/parser/BUILD
+++ b/zetasql/parser/BUILD
@@ -23,1 +23,1 @@
-    default_visibility = ["//zetasql/base:zetasql_implementation"],
+    default_visibility = ["//visibility:public"],
diff --git a/zetasql/public/types/BUILD b/zetasql/public/types/BUILD
index 235a1ce..3e5b70a 100644
--- a/zetasql/public/types/BUILD
+++ b/zetasql/public/types/BUILD
@@ -17,1 +17,1 @@
-package(default_visibility = ["//zetasql/base:zetasql_implementation"])
+package(default_visibility = ["//visibility:public"])
diff --git a/zetasql/public/types/type.h b/zetasql/public/types/type.h
index 235a1ce..3e5b70a 100644
--- a/zetasql/public/types/type.h
+++ b/zetasql/public/types/type.h
@@ -555,46 +555,7 @@ class Type {
     // error.
     std::optional<int64_t> file_descriptor_sets_max_size_bytes = std::nullopt;
   };
-
- protected:
-  // Types can only be created and destroyed by TypeFactory.
-  Type(const TypeFactory* factory, TypeKind kind);
-  virtual ~Type();
-
-  bool EqualsImpl(const Type* other_type, bool equivalent) const {
-    if (this == other_type) {
-      return true;
-    }
-    if (kind() != other_type->kind()) {
-      return false;
-    }
-    return EqualsForSameKind(other_type, equivalent);
-  }
-
-  // Hashes the type. Hash is generated based on a type's kind and (if type is
-  // not built-in simple type) on a type's parameter.
-  absl::HashState Hash(absl::HashState state) const;
-
-  // Hashes the type's parameter of non-simple (parameterized) types. Simple
-  // built-in types should not update the hash state.
-  virtual absl::HashState HashTypeParameter(absl::HashState state) const = 0;
-
-  // Internal implementation for Serialize methods.  This will append
-  // Type information to <type_proto>, so the caller should make sure
-  // that <type_proto> has been initialized properly before invoking.
-  // <options> controls whether FileDescriptors are deep-scanned and
-  // FileDescriptorSets are generated, and also whether there are any limits
-  // placed on the size of the FileDescriptorSets.
-  virtual absl::Status SerializeToProtoAndDistinctFileDescriptorsImpl(
-      const BuildFileDescriptorSetMapOptions& options, TypeProto* type_proto,
-      FileDescriptorSetMap* file_descriptor_set_map) const = 0;
-
-  // Returns estimated size of memory owned by this type. Note: type can never
-  // own another type, only reference (all types are owned by TypeFactory). So,
-  // this function never calls GetEstimatedOwnedMemoryBytesSize for other types
-  // (such as element types of arrays or field types of structs).
-  virtual int64_t GetEstimatedOwnedMemoryBytesSize() const = 0;
-
+  
   // Formatting options that can be provided to FormatValueContent.
   struct FormatValueContentOptions {
     enum class Mode {
@@ -637,6 +598,45 @@ class Type {
     static const int kIndentStep = 2;
   };
 
+ protected:
+  // Types can only be created and destroyed by TypeFactory.
+  Type(const TypeFactory* factory, TypeKind kind);
+  virtual ~Type();
+
+  bool EqualsImpl(const Type* other_type, bool equivalent) const {
+    if (this == other_type) {
+      return true;
+    }
+    if (kind() != other_type->kind()) {
+      return false;
+    }
+    return EqualsForSameKind(other_type, equivalent);
+  }
+
+  // Hashes the type. Hash is generated based on a type's kind and (if type is
+  // not built-in simple type) on a type's parameter.
+  absl::HashState Hash(absl::HashState state) const;
+
+  // Hashes the type's parameter of non-simple (parameterized) types. Simple
+  // built-in types should not update the hash state.
+  virtual absl::HashState HashTypeParameter(absl::HashState state) const = 0;
+
+  // Internal implementation for Serialize methods.  This will append
+  // Type information to <type_proto>, so the caller should make sure
+  // that <type_proto> has been initialized properly before invoking.
+  // <options> controls whether FileDescriptors are deep-scanned and
+  // FileDescriptorSets are generated, and also whether there are any limits
+  // placed on the size of the FileDescriptorSets.
+  virtual absl::Status SerializeToProtoAndDistinctFileDescriptorsImpl(
+      const BuildFileDescriptorSetMapOptions& options, TypeProto* type_proto,
+      FileDescriptorSetMap* file_descriptor_set_map) const = 0;
+
+  // Returns estimated size of memory owned by this type. Note: type can never
+  // own another type, only reference (all types are owned by TypeFactory). So,
+  // this function never calls GetEstimatedOwnedMemoryBytesSize for other types
+  // (such as element types of arrays or field types of structs).
+  virtual int64_t GetEstimatedOwnedMemoryBytesSize() const = 0;
+
   // List of DebugStringImpl outputs. Used to serve as a stack in
   // DebugStringImpl to protect from stack overflows.
   // Note: SWIG will fail to process this file if we remove a white space
diff --git a/zetasql/public/value.cc b/zetasql/public/value.cc
index 50deb34..2070935 100644
--- a/zetasql/public/value.cc
+++ b/zetasql/public/value.cc
@@ -909,7 +909,7 @@ std::string Value::DebugString(bool verbose) const {
 
 // Format will wrap arrays and structs.
 std::string Value::Format(bool print_top_level_type) const {
-  return FormatInternal(
+  return FormatInternal(Type::FormatValueContentOptions
       {.force_type_at_top_level = print_top_level_type, .indent = 0});
 }
 
@@ -1169,7 +1169,7 @@ std::string Value::FormatInternal(
     std::vector<std::string> element_strings(elements().size());
     for (int i = 0; i < elements().size(); ++i) {
       element_strings[i] =
-          elements()[i].FormatInternal(options.IncreaseIndent());
+          elements()[i].FormatInternal(Type::FormatValueContentOptions{options.IncreaseIndent()});
     }
     // Sanitize any '$' characters before creating substitution template. "$$"
     // is replaced by "$" in the output from absl::Substitute.
@@ -1211,7 +1211,7 @@ std::string Value::FormatInternal(
     const StructType* struct_type = type()->AsStruct();
     std::vector<std::string> field_strings(struct_type->num_fields());
     for (int i = 0; i < struct_type->num_fields(); i++) {
-      field_strings[i] = fields()[i].FormatInternal(options.IncreaseIndent());
+      field_strings[i] = fields()[i].FormatInternal(Type::FormatValueContentOptions{options.IncreaseIndent()});
     }
     // Sanitize any '$' characters before creating substitution template. "$$"
     // is replaced by "$" in the output from absl::Substitute.
@@ -1257,9 +1257,9 @@ std::string Value::FormatInternal(
     }
     std::vector<std::string> boundaries_strings;
     boundaries_strings.push_back(
-        start().FormatInternal(options.IncreaseIndent()));
+        start().FormatInternal(Type::FormatValueContentOptions{options.IncreaseIndent()}));
     boundaries_strings.push_back(
-        end().FormatInternal(options.IncreaseIndent()));
+        end().FormatInternal(Type::FormatValueContentOptions{options.IncreaseIndent()}));
     // Sanitize any '$' characters before creating substitution template. "$$"
     // is replaced by "$" in the output from absl::Substitute.
     std::string templ =
