//
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//


// Helper regex definitions to be used in real token definitions.
TOKEN:
{
    <#DEC_DIGIT:            ["0"-"9"]>
  | <#HEX_DIGIT:            ["0"-"9", "A"-"F"]>
  | <#LETTER_OR_UNDERSCORE: ["a"-"z","A"-"Z","_"]>
  | <#SCALE_FACTOR:         "e" (["+", "-"])? ( <DEC_DIGIT> )+ >
}

TOKEN: /* Literals */
{
    <ID: (<LETTER_OR_UNDERSCORE>) (<LETTER_OR_UNDERSCORE> | <DEC_DIGIT>)* >
  | <INTEGER_LITERAL: ("-")? ( <DEC_DIGIT> (<DEC_DIGIT>)* |
                               "0x" (<HEX_DIGIT>)+ ) >
  | <QUOTED_ID: "`" (~["\n","\r","`","0"-"9"]) (~["\n","\r","`"])* "`" >
}

/* ---------------- General Productions --------------------- */

/**
 * Basic named reference, used for tables, columns, option names, etc.
 *
 * the #void means to not create a node
 */
void identifier() #void :
{}
{
    <ID>
  | <QUOTED_ID>
  | pseudoReservedWord()
}

void qualified_identifier() #void :
{}
{
  ((identifier() #part) (("." identifier() #part)*))
}

void identifier_list() :
{}
{
  (identifier() #identifier) ("," identifier() #identifier)*
}

void qualified_identifier_list() :
{}
{
  (qualified_identifier() #identifier) ("," qualified_identifier() #identifier)*
}

void path() :
{}
{
  identifier()
}

// Parses an Int64 value
void int_value() :
{}
{
  <INTEGER_LITERAL>
}

// Parses a String value
void string_value() :
{}
{
  any_string_literal()
}

void ddl_statement() :
{}
{
  (   alter_statement()
    | create_statement()
    | drop_statement()
    | analyze_statement()
  )
  <EOF>
}

void create_statement() #void :
{}
{
  <CREATE>
  (   create_database_statement()
    | create_table_statement()
    | create_index_statement()

    | create_or_replace_statement()
    | create_change_stream_statement()
    | create_sequence_statement()
  )
}

void create_or_replace_statement() :
{}
{
  [ or_replace() ]
  (
      create_view_statement()
  )
}

void alter_index_statement() :
{}
{
  <INDEX>
  ( qualified_identifier() #name )
  ( <ADD> #add | <DROP> #drop )
  <STORED> <COLUMN>
  ( identifier() #column_name )
}

void options_clause() :
{}
{
  <OPTIONS> option_list()
}

void create_database_statement() :
{}
{
  <DATABASE>
  identifier() #db_name
  [ options_clause() ]
}

void create_table_statement() :
{}
{
  <TABLE>
  [ if_not_exists() ]
  qualified_identifier() #name
  "(" [ table_element() ( LOOKAHEAD(2) "," table_element() )* [ "," ] ] ")"
  primary_key()
  [ LOOKAHEAD(2) "," table_interleave_clause() ]
  [ LOOKAHEAD(2) "," row_deletion_policy_clause() ]
}

void table_element() #void :
{}
{
    LOOKAHEAD(3) foreign_key()
  | LOOKAHEAD(3) check_constraint()
  | column_def()
}

void column_def() :
{}
{
  identifier() #name
  column_type()
  [ <NOT> <NULLL> #not_null ]
  [ generation_clause() | column_default_clause() ]
  [ <HIDDEN> #hidden ]
  [ options_clause() ]
}

void column_def_alter_attrs() :
{}
{
  column_type()
  [ <NOT> <NULLL> #not_null ]
  [ generation_clause() | column_default_clause() ]
}

void column_def_alter() :
{}
{
    LOOKAHEAD(2) <SET> ( options_clause()
                         | column_default_clause()
                       )
  | LOOKAHEAD(2) <DROP> <DEFAULTT> #drop_column_default
  | column_def_alter_attrs()
}

void column_type() :
{}
{
    <FLOAT64>
  | <INT64>
  | <BOOL>
  | <STRING> "(" column_length() #length ")"
  | <BYTES> "(" column_length() #length ")"
  | <TIMESTAMP>
  | <DATE>
  | <NUMERIC>
  | <PG> "." qualified_identifier() #pgtype
  | <JSON>
  | <ARRAY> "<" column_type() ">"

}

void column_length() :
{}
{
  <MAX> | int_value()
}

void generation_clause() :
{}
{
  <AS> "(" expression() #expression ")"
  [<STORED> #stored]
}

void column_default_clause() :
{}
{
  <DEFAULTT> "(" expression() #column_default_expression ")"
}

void primary_key() #void :
{}
{
  <PRIMARY> <KEY> (key() #primary_key)
}

void foreign_key() :
{}
{
  [ <CONSTRAINT> identifier() #constraint_name ]
  <FOREIGN> <KEY>
    "(" identifier_list() #referencing_columns ")"
  <REFERENCES> qualified_identifier() #referenced_table
    "(" identifier_list() #referenced_columns ")"
  [ <ON> <DELETE> referential_action() #on_delete ]
}

void referential_action() :
{}
{
    <NO> <ACTION> #no_action
  | <CASCADE> #cascade
}

void statement_token_no_paren() :
{}
{
  googlesql_statement_token_no_paren()
}

void check_constraint() :
{}
{
  [ <CONSTRAINT> identifier() #constraint_name ]
  <CHECK> "(" expression() #check_constraint_expression ")"
}

void table_interleave_clause() :
{}
{
  <INTERLEAVE> <IN> <PARENT> qualified_identifier() #interleave_in
    [ on_delete_clause() ]
}

void row_deletion_policy_clause():
{}
{
  <ROW> <DELETION> <POLICY> "(" row_deletion_policy_expression() ")"
}

void row_deletion_policy_expression():
{}
{
  identifier() #row_deletion_policy_function
  "(" identifier() #row_deletion_policy_column "," interval_expression() ")"
}

void interval_expression():
{}
{
  <INTERVAL> int_value() <DAY>
}

void on_delete_clause() :
{}
{
  <ON> <DELETE> ( <CASCADE> #cascade | <NO> <ACTION> #no_action )
}

void create_index_statement() :
{}
{
  [ <UNIQUE> #unique_index ]
  [ <NULL_FILTERED> #null_filtered ]
  <INDEX>
  [ if_not_exists() ]
  qualified_identifier() #name
  <ON> qualified_identifier() #table
  key() #columns
  [ <STORING> stored_column_list() ]
  [ LOOKAHEAD(2) "," index_interleave_clause() ]
}


void index_interleave_clause() :
{}
{
  <INTERLEAVE> <IN> qualified_identifier() #interleave_in
}

void create_change_stream_statement() :
{}
{
  <CHANGE> <STREAM> qualified_identifier() #name
  [ change_stream_for_clause() ]
  [ options_clause() ]
}

void change_stream_for_clause() :
{}
{
  <FOR>
  (   <ALL> #all
    | change_stream_tracked_tables()
  )
}

void change_stream_tracked_tables() :
{}
{
  change_stream_tracked_tables_entry()
  ( "," change_stream_tracked_tables_entry() )*
}

void change_stream_tracked_tables_entry() :
{}
{
  qualified_identifier() #table
  [ (
      "(" [ (identifier() #column) ( "," identifier() #column )* ] ")"
    ) #explicit_columns // Needed to distinguish between `Table` and `Table()`
  ]
}

void create_sequence_statement() :
{}
{
  <SEQUENCE> [ if_not_exists() ] qualified_identifier() #name
  [ options_clause() ]
}

void key() #void :
{}
{
  "("
    [ // parts may be empty for primary keys
      key_part()
      ( "," key_part() )*
    ]
  ")"
}

void key_part() :
{}
{
  path()
  [   <ASC>
    | <DESC> #desc
  ]
}

void stored_column() :
{}
{
  path()
}

void stored_column_list() :
{}
{
  "(" stored_column()
    ( "," stored_column() )*
  ")"
}

void option_list() #void :
{}
{
  "("
  option_key_val() ( LOOKAHEAD(2) "," option_key_val() )*
  ")"
}

void option_key_val() :
{}
{
  identifier() #key
  "="
  (   <NULLL> #nulll
    | <TRUEE> #bool_true_val
    | <FALSEE> #bool_false_val
    | <INTEGER_LITERAL> #integer_val
    | string_value() #str_val
  )
}

void or_replace() :
{}
{
  <OR> <REPLACE>
}

void sql_security() :
{}
{
  <INVOKER>
}

void create_view_statement() :
{}
{
  ( <VIEW> )
  ( qualified_identifier() #name )
  [ <SQL> <SECURITY> sql_security() ]
  <AS> statement_tokens() #view_definition
}

void statement_tokens() :
{}
{
  ( statement_token_no_paren()
  | "("
  | ")" )+
}

void if_not_exists() :
{}
{
  <IF> <NOT> <EXISTS>
}

void if_exists() :
{}
{
  <IF> <EXISTS>
}

void drop_statement() :
{}
{
  <DROP>
    ( <TABLE> #table [ if_exists() ]
      | <INDEX> #index [ if_exists() ]

      | <VIEW> #view [ if_exists() ]
      | <CHANGE> <STREAM> #change_stream
      | <SEQUENCE> #sequence [ if_exists() ]
    ) qualified_identifier() #name
}

void alter_statement() #void :
{}
{
  <ALTER>
  (
    alter_table_statement()
    | alter_change_stream_statement()
    | alter_index_statement()
    | alter_sequence_statement()
  )
}

void alter_table_statement() :
{}
{
  <TABLE> (qualified_identifier() #table_name)
  (   LOOKAHEAD(3) <DROP> <CONSTRAINT> #drop_constraint identifier() #constraint_name
    | LOOKAHEAD(3) <DROP> <ROW> <DELETION> <POLICY> #drop_row_deletion_policy
    | LOOKAHEAD(3) <DROP> #drop_column [LOOKAHEAD(2) <COLUMN>]
        (identifier() #column_name)
    | LOOKAHEAD(1) <ALTER> #alter_column [LOOKAHEAD(2) <COLUMN>]
        (identifier() #name) column_def_alter()
    | LOOKAHEAD(2) <SET> #set_on_delete on_delete_clause()
    | LOOKAHEAD(4) <ADD> foreign_key()
    | LOOKAHEAD(4) <ADD> check_constraint()
    | LOOKAHEAD(4) <ADD> row_deletion_policy_clause() #add_row_deletion_policy
    // ADD COLUMN could mask the above ADD clauses, so putting it at the end.
    | LOOKAHEAD(1) <ADD> #add_column [
        LOOKAHEAD(6) <COLUMN> [ if_not_exists() ]
      ] column_def()
    | <REPLACE> row_deletion_policy_clause() #replace_row_deletion_policy
  )
}

void alter_change_stream_statement() :
{}
{
  <CHANGE> <STREAM> (qualified_identifier() #name)
  (   LOOKAHEAD(2) <SET> change_stream_for_clause()
    | <SET> options_clause()
    | <DROP> <FOR> <ALL> #drop_for_all
  )
}

void alter_sequence_statement() :
{}
{
  <SEQUENCE> [ if_exists() ] (qualified_identifier() #name) <SET> options_clause()

}

void analyze_statement() :
{}
{
  <ANALYZE>
}

TOKEN:  /* catch unexpected characters; must be last in file */
{
  <UNEXPECTED_CHARACTER: ~[]>

  /* These tokens are injected by validation logic to signal error type. */
  | <ILLEGAL_STRING_ESCAPE: "\\" ~[]> : DEFAULT
  | <ILLEGAL_BYTES_ESCAPE: "\\" ~[]> : DEFAULT
}
