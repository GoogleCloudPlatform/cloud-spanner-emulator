//
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

#include "backend/query/information_schema_catalog.h"

#include <string>

#include "backend/schema/printer/print_ddl.h"

namespace google {
namespace spanner {
namespace emulator {
namespace backend {

namespace {

using zetasql::types::BoolType;
using zetasql::types::BytesType;
using zetasql::types::Int64Type;
using zetasql::types::StringType;
using zetasql::values::Bool;
using zetasql::values::Int64;
using zetasql::values::NullBytes;
using zetasql::values::NullInt64;
using zetasql::values::NullString;
using zetasql::values::String;

constexpr char kInformationSchema[] = "INFORMATION_SCHEMA";

// Metadata for information schema columns. This was generated by running the
// following query against cloud spanner:
//
//   SELECT TABLE_NAME, COLUMN_NAME, IS_NULLABLE, SPANNER_TYPE
//   FROM INFORMATION_SCHEMA.COLUMNS
//   WHERE TABLE_SCHEMA='INFORMATION_SCHEMA'
//   ORDER BY TABLE_NAME ASC, COLUMN_NAME ASC;
//
struct ColumnsMetaEntry {
  const char* table_name;
  const char* column_name;
  const char* is_nullable;
  const char* spanner_type;
};
const std::vector<ColumnsMetaEntry>* ColumnsMetadata() {
  // clang-format off
  static const auto* data = new std::vector<ColumnsMetaEntry>{
    {"CHECK_CONSTRAINTS", "CHECK_CLAUSE", "NO", "STRING(MAX)"},
    {"CHECK_CONSTRAINTS", "CONSTRAINT_CATALOG", "NO", "STRING(MAX)"},
    {"CHECK_CONSTRAINTS", "CONSTRAINT_NAME", "NO", "STRING(MAX)"},
    {"CHECK_CONSTRAINTS", "CONSTRAINT_SCHEMA", "NO", "STRING(MAX)"},
    {"CHECK_CONSTRAINTS", "SPANNER_STATE", "NO", "STRING(MAX)"},
    {"COLUMNS", "COLUMN_DEFAULT", "YES", "BYTES(MAX)"},
    {"COLUMNS", "COLUMN_NAME", "NO", "STRING(MAX)"},
    {"COLUMNS", "DATA_TYPE", "YES", "STRING(MAX)"},
    {"COLUMNS", "GENERATION_EXPRESSION", "YES", "STRING(MAX)"},
    {"COLUMNS", "IS_GENERATED", "NO", "STRING(MAX)"},
    {"COLUMNS", "IS_NULLABLE", "YES", "STRING(MAX)"},
    {"COLUMNS", "IS_STORED", "YES", "STRING(MAX)"},
    {"COLUMNS", "ORDINAL_POSITION", "NO", "INT64"},
    {"COLUMNS", "SPANNER_STATE", "YES", "STRING(MAX)"},
    {"COLUMNS", "SPANNER_TYPE", "YES", "STRING(MAX)"},
    {"COLUMNS", "TABLE_CATALOG", "NO", "STRING(MAX)"},
    {"COLUMNS", "TABLE_NAME", "NO", "STRING(MAX)"},
    {"COLUMNS", "TABLE_SCHEMA", "NO", "STRING(MAX)"},
    {"COLUMN_OPTIONS", "COLUMN_NAME", "NO", "STRING(MAX)"},
    {"COLUMN_OPTIONS", "OPTION_NAME", "NO", "STRING(MAX)"},
    {"COLUMN_OPTIONS", "OPTION_TYPE", "NO", "STRING(MAX)"},
    {"COLUMN_OPTIONS", "OPTION_VALUE", "NO", "STRING(MAX)"},
    {"COLUMN_OPTIONS", "TABLE_CATALOG", "NO", "STRING(MAX)"},
    {"COLUMN_OPTIONS", "TABLE_NAME", "NO", "STRING(MAX)"},
    {"COLUMN_OPTIONS", "TABLE_SCHEMA", "NO", "STRING(MAX)"},
    {"CONSTRAINT_COLUMN_USAGE", "COLUMN_NAME", "NO", "STRING(MAX)"},
    {"CONSTRAINT_COLUMN_USAGE", "CONSTRAINT_CATALOG", "NO", "STRING(MAX)"},
    {"CONSTRAINT_COLUMN_USAGE", "CONSTRAINT_NAME", "NO", "STRING(MAX)"},
    {"CONSTRAINT_COLUMN_USAGE", "CONSTRAINT_SCHEMA", "NO", "STRING(MAX)"},
    {"CONSTRAINT_COLUMN_USAGE", "TABLE_CATALOG", "NO", "STRING(MAX)"},
    {"CONSTRAINT_COLUMN_USAGE", "TABLE_NAME", "NO", "STRING(MAX)"},
    {"CONSTRAINT_COLUMN_USAGE", "TABLE_SCHEMA", "NO", "STRING(MAX)"},
    {"CONSTRAINT_TABLE_USAGE", "CONSTRAINT_CATALOG", "NO", "STRING(MAX)"},
    {"CONSTRAINT_TABLE_USAGE", "CONSTRAINT_NAME", "NO", "STRING(MAX)"},
    {"CONSTRAINT_TABLE_USAGE", "CONSTRAINT_SCHEMA", "NO", "STRING(MAX)"},
    {"CONSTRAINT_TABLE_USAGE", "TABLE_CATALOG", "NO", "STRING(MAX)"},
    {"CONSTRAINT_TABLE_USAGE", "TABLE_NAME", "NO", "STRING(MAX)"},
    {"CONSTRAINT_TABLE_USAGE", "TABLE_SCHEMA", "NO", "STRING(MAX)"},
    {"DATABASE_OPTIONS", "CATALOG_NAME", "NO", "STRING(MAX)"},
    {"DATABASE_OPTIONS", "OPTION_NAME", "NO", "STRING(MAX)"},
    {"DATABASE_OPTIONS", "OPTION_TYPE", "NO", "STRING(MAX)"},
    {"DATABASE_OPTIONS", "OPTION_VALUE", "NO", "STRING(MAX)"},
    {"DATABASE_OPTIONS", "SCHEMA_NAME", "NO", "STRING(MAX)"},
    {"INDEXES", "INDEX_NAME", "NO", "STRING(MAX)"},
    {"INDEXES", "INDEX_STATE", "NO", "STRING(100)"},
    {"INDEXES", "INDEX_TYPE", "NO", "STRING(MAX)"},
    {"INDEXES", "IS_NULL_FILTERED", "NO", "BOOL"},
    {"INDEXES", "IS_UNIQUE", "NO", "BOOL"},
    {"INDEXES", "PARENT_TABLE_NAME", "NO", "STRING(MAX)"},
    {"INDEXES", "SPANNER_IS_MANAGED", "NO", "BOOL"},
    {"INDEXES", "TABLE_CATALOG", "NO", "STRING(MAX)"},
    {"INDEXES", "TABLE_NAME", "NO", "STRING(MAX)"},
    {"INDEXES", "TABLE_SCHEMA", "NO", "STRING(MAX)"},
    {"INDEX_COLUMNS", "COLUMN_NAME", "NO", "STRING(MAX)"},
    {"INDEX_COLUMNS", "COLUMN_ORDERING", "YES", "STRING(MAX)"},
    {"INDEX_COLUMNS", "INDEX_NAME", "NO", "STRING(MAX)"},
    {"INDEX_COLUMNS", "INDEX_TYPE", "NO", "STRING(MAX)"},
    {"INDEX_COLUMNS", "IS_NULLABLE", "YES", "STRING(MAX)"},
    {"INDEX_COLUMNS", "ORDINAL_POSITION", "YES", "INT64"},
    {"INDEX_COLUMNS", "SPANNER_TYPE", "YES", "STRING(MAX)"},
    {"INDEX_COLUMNS", "TABLE_CATALOG", "NO", "STRING(MAX)"},
    {"INDEX_COLUMNS", "TABLE_NAME", "NO", "STRING(MAX)"},
    {"INDEX_COLUMNS", "TABLE_SCHEMA", "NO", "STRING(MAX)"},
    {"KEY_COLUMN_USAGE", "COLUMN_NAME", "NO", "STRING(MAX)"},
    {"KEY_COLUMN_USAGE", "CONSTRAINT_CATALOG", "NO", "STRING(MAX)"},
    {"KEY_COLUMN_USAGE", "CONSTRAINT_NAME", "NO", "STRING(MAX)"},
    {"KEY_COLUMN_USAGE", "CONSTRAINT_SCHEMA", "NO", "STRING(MAX)"},
    {"KEY_COLUMN_USAGE", "ORDINAL_POSITION", "NO", "INT64"},
    {"KEY_COLUMN_USAGE", "POSITION_IN_UNIQUE_CONSTRAINT", "YES", "INT64"},
    {"KEY_COLUMN_USAGE", "TABLE_CATALOG", "NO", "STRING(MAX)"},
    {"KEY_COLUMN_USAGE", "TABLE_NAME", "NO", "STRING(MAX)"},
    {"KEY_COLUMN_USAGE", "TABLE_SCHEMA", "NO", "STRING(MAX)"},
    {"REFERENTIAL_CONSTRAINTS", "CONSTRAINT_CATALOG", "NO", "STRING(MAX)"},
    {"REFERENTIAL_CONSTRAINTS", "CONSTRAINT_NAME", "NO", "STRING(MAX)"},
    {"REFERENTIAL_CONSTRAINTS", "CONSTRAINT_SCHEMA", "NO", "STRING(MAX)"},
    {"REFERENTIAL_CONSTRAINTS", "DELETE_RULE", "NO", "STRING(MAX)"},
    {"REFERENTIAL_CONSTRAINTS", "MATCH_OPTION", "NO", "STRING(MAX)"},
    {"REFERENTIAL_CONSTRAINTS", "SPANNER_STATE", "NO", "STRING(MAX)"},
    {"REFERENTIAL_CONSTRAINTS", "UNIQUE_CONSTRAINT_CATALOG", "YES", "STRING(MAX)"},  // NOLINT
    {"REFERENTIAL_CONSTRAINTS", "UNIQUE_CONSTRAINT_NAME", "YES", "STRING(MAX)"},
    {"REFERENTIAL_CONSTRAINTS", "UNIQUE_CONSTRAINT_SCHEMA", "YES", "STRING(MAX)"},  // NOLINT
    {"REFERENTIAL_CONSTRAINTS", "UPDATE_RULE", "NO", "STRING(MAX)"},
    {"SCHEMATA", "CATALOG_NAME", "NO", "STRING(MAX)"},
    {"SCHEMATA", "EFFECTIVE_TIMESTAMP", "YES", "INT64"},
    {"SCHEMATA", "SCHEMA_NAME", "NO", "STRING(MAX)"},
    {"SPANNER_STATISTICS", "ALLOW_GC", "NO", "BOOL"},
    {"SPANNER_STATISTICS", "CATALOG_NAME", "NO", "STRING(MAX)"},
    {"SPANNER_STATISTICS", "PACKAGE_NAME", "NO", "STRING(MAX)"},
    {"SPANNER_STATISTICS", "SCHEMA_NAME", "NO", "STRING(MAX)"},
    {"TABLES", "ON_DELETE_ACTION", "YES", "STRING(MAX)"},
    {"TABLES", "PARENT_TABLE_NAME", "YES", "STRING(MAX)"},
    {"TABLES", "SPANNER_STATE", "YES", "STRING(MAX)"},
    {"TABLES", "TABLE_CATALOG", "NO", "STRING(MAX)"},
    {"TABLES", "TABLE_NAME", "NO", "STRING(MAX)"},
    {"TABLES", "TABLE_SCHEMA", "NO", "STRING(MAX)"},
    {"TABLES", "TABLE_TYPE", "NO", "STRING(32)"},
    {"TABLE_CONSTRAINTS", "CONSTRAINT_CATALOG", "NO", "STRING(MAX)"},
    {"TABLE_CONSTRAINTS", "CONSTRAINT_NAME", "NO", "STRING(MAX)"},
    {"TABLE_CONSTRAINTS", "CONSTRAINT_SCHEMA", "NO", "STRING(MAX)"},
    {"TABLE_CONSTRAINTS", "CONSTRAINT_TYPE", "NO", "STRING(MAX)"},
    {"TABLE_CONSTRAINTS", "ENFORCED", "NO", "STRING(MAX)"},
    {"TABLE_CONSTRAINTS", "INITIALLY_DEFERRED", "NO", "STRING(MAX)"},
    {"TABLE_CONSTRAINTS", "IS_DEFERRABLE", "NO", "STRING(MAX)"},
    {"TABLE_CONSTRAINTS", "TABLE_CATALOG", "NO", "STRING(MAX)"},
    {"TABLE_CONSTRAINTS", "TABLE_NAME", "NO", "STRING(MAX)"},
    {"TABLE_CONSTRAINTS", "TABLE_SCHEMA", "NO", "STRING(MAX)"},
  };
  // clang-format on
  return data;
}

bool IsNullable(const ColumnsMetaEntry& column) {
  return std::string(column.is_nullable) == "YES";
}

// Metadata for information schema index columns. This was generated by running
// the following query against cloud spanner:
//
//   SELECT TABLE_NAME, COLUMN_NAME, IS_NULLABLE, COLUMN_ORDERING, SPANNER_TYPE
//   FROM INFORMATION_SCHEMA.INDEX_COLUMNS
//   WHERE TABLE_SCHEMA='INFORMATION_SCHEMA'
//   ORDER BY TABLE_NAME ASC, COLUMN_NAME ASC;
//
struct IndexColumnsMetaEntry {
  const char* table_name;
  const char* column_name;
  const char* is_nullable;
  const char* column_ordering;
  const char* spanner_type;

  // Not all information schema tables have a primary key on the prefix of
  // table columns. CONSTRAINT_COLUMN_USAGE, for example, has table columns:
  //
  //   TABLE_CATALOG
  //   TABLE_SCHEMA
  //   TABLE_NAME
  //   COLUMN_NAME
  //   CONSTRAINT_CATALOG
  //   CONSTRAINT_SCHEMA
  //   CONSTRAINT_NAME
  //
  // but its primary key is:
  //
  //   CONSTRAINT_CATALOG
  //   CONSTRAINT_SCHEMA
  //   CONSTRAINT_NAME
  //   COLUMN_NAME
  //
  // which correspond to ordinal positions [1, 2, 3, 4].
  //
  // The default position of 0 indicates that the column is in the same ordinal
  // position in both the table and its primary key.
  const int primary_key_ordinal = 0;
};
const std::vector<IndexColumnsMetaEntry>* IndexColumnsMetadata() {
  // clang-format off
  static const auto* data = new std::vector<IndexColumnsMetaEntry>{
    {"CHECK_CONSTRAINTS", "CONSTRAINT_CATALOG", "NO", "ASC", "STRING(MAX)"},
    {"CHECK_CONSTRAINTS", "CONSTRAINT_NAME", "NO", "ASC", "STRING(MAX)"},
    {"CHECK_CONSTRAINTS", "CONSTRAINT_SCHEMA", "NO", "ASC", "STRING(MAX)"},
    {"COLUMNS", "COLUMN_NAME", "NO", "ASC", "STRING(MAX)"},
    {"COLUMNS", "TABLE_CATALOG", "NO", "ASC", "STRING(MAX)"},
    {"COLUMNS", "TABLE_NAME", "NO", "ASC", "STRING(MAX)"},
    {"COLUMNS", "TABLE_SCHEMA", "NO", "ASC", "STRING(MAX)"},
    {"COLUMN_OPTIONS", "COLUMN_NAME", "NO", "ASC", "STRING(MAX)"},
    {"COLUMN_OPTIONS", "OPTION_NAME", "NO", "ASC", "STRING(MAX)"},
    {"COLUMN_OPTIONS", "TABLE_CATALOG", "NO", "ASC", "STRING(MAX)"},
    {"COLUMN_OPTIONS", "TABLE_NAME", "NO", "ASC", "STRING(MAX)"},
    {"COLUMN_OPTIONS", "TABLE_SCHEMA", "NO", "ASC", "STRING(MAX)"},
    {"CONSTRAINT_COLUMN_USAGE", "COLUMN_NAME", "NO", "ASC", "STRING(MAX)", 4},
    {"CONSTRAINT_COLUMN_USAGE", "CONSTRAINT_CATALOG", "NO", "ASC", "STRING(MAX)", 1},  // NOLINT
    {"CONSTRAINT_COLUMN_USAGE", "CONSTRAINT_NAME", "NO", "ASC", "STRING(MAX)", 3},  // NOLINT
    {"CONSTRAINT_COLUMN_USAGE", "CONSTRAINT_SCHEMA", "NO", "ASC", "STRING(MAX)", 2},  // NOLINT
    {"CONSTRAINT_TABLE_USAGE", "CONSTRAINT_CATALOG", "NO", "ASC", "STRING(MAX)"},  // NOLINT
    {"CONSTRAINT_TABLE_USAGE", "CONSTRAINT_NAME", "NO", "ASC", "STRING(MAX)"},
    {"CONSTRAINT_TABLE_USAGE", "CONSTRAINT_SCHEMA", "NO", "ASC", "STRING(MAX)"},
    {"CONSTRAINT_TABLE_USAGE", "TABLE_CATALOG", "NO", "ASC", "STRING(MAX)"},
    {"CONSTRAINT_TABLE_USAGE", "TABLE_NAME", "NO", "ASC", "STRING(MAX)"},
    {"CONSTRAINT_TABLE_USAGE", "TABLE_SCHEMA", "NO", "ASC", "STRING(MAX)"},
    {"DATABASE_OPTIONS", "CATALOG_NAME", "NO", "ASC", "STRING(MAX)"},
    {"DATABASE_OPTIONS", "OPTION_NAME", "NO", "ASC", "STRING(MAX)"},
    {"DATABASE_OPTIONS", "SCHEMA_NAME", "NO", "ASC", "STRING(MAX)"},
    {"INDEXES", "INDEX_NAME", "NO", "ASC", "STRING(MAX)"},
    {"INDEXES", "INDEX_TYPE", "NO", "ASC", "STRING(MAX)"},
    {"INDEXES", "TABLE_CATALOG", "NO", "ASC", "STRING(MAX)"},
    {"INDEXES", "TABLE_NAME", "NO", "ASC", "STRING(MAX)"},
    {"INDEXES", "TABLE_SCHEMA", "NO", "ASC", "STRING(MAX)"},
    {"INDEX_COLUMNS", "COLUMN_NAME", "NO", "ASC", "STRING(MAX)"},
    {"INDEX_COLUMNS", "INDEX_NAME", "NO", "ASC", "STRING(MAX)"},
    {"INDEX_COLUMNS", "INDEX_TYPE", "NO", "ASC", "STRING(MAX)"},
    {"INDEX_COLUMNS", "TABLE_CATALOG", "NO", "ASC", "STRING(MAX)"},
    {"INDEX_COLUMNS", "TABLE_NAME", "NO", "ASC", "STRING(MAX)"},
    {"INDEX_COLUMNS", "TABLE_SCHEMA", "NO", "ASC", "STRING(MAX)"},
    {"KEY_COLUMN_USAGE", "COLUMN_NAME", "NO", "ASC", "STRING(MAX)"},
    {"KEY_COLUMN_USAGE", "CONSTRAINT_CATALOG", "NO", "ASC", "STRING(MAX)"},
    {"KEY_COLUMN_USAGE", "CONSTRAINT_NAME", "NO", "ASC", "STRING(MAX)"},
    {"KEY_COLUMN_USAGE", "CONSTRAINT_SCHEMA", "NO", "ASC", "STRING(MAX)"},
    {"REFERENTIAL_CONSTRAINTS", "CONSTRAINT_CATALOG", "NO", "ASC", "STRING(MAX)"},  // NOLINT
    {"REFERENTIAL_CONSTRAINTS", "CONSTRAINT_NAME", "NO", "ASC", "STRING(MAX)"},
    {"REFERENTIAL_CONSTRAINTS", "CONSTRAINT_SCHEMA", "NO", "ASC", "STRING(MAX)"},  // NOLINT
    {"SCHEMATA", "CATALOG_NAME", "NO", "ASC", "STRING(MAX)"},
    {"SCHEMATA", "SCHEMA_NAME", "NO", "ASC", "STRING(MAX)"},
    {"SPANNER_STATISTICS", "CATALOG_NAME", "NO", "ASC", "STRING(MAX)"},
    {"SPANNER_STATISTICS", "SCHEMA_NAME", "NO", "ASC", "STRING(MAX)"},
    {"SPANNER_STATISTICS", "PACKAGE_NAME", "NO", "ASC", "STRING(MAX)"},
    {"TABLES", "TABLE_CATALOG", "NO", "ASC", "STRING(MAX)"},
    {"TABLES", "TABLE_NAME", "NO", "ASC", "STRING(MAX)"},
    {"TABLES", "TABLE_SCHEMA", "NO", "ASC", "STRING(MAX)"},
    {"TABLE_CONSTRAINTS", "CONSTRAINT_CATALOG", "NO", "ASC", "STRING(MAX)"},
    {"TABLE_CONSTRAINTS", "CONSTRAINT_NAME", "NO", "ASC", "STRING(MAX)"},
    {"TABLE_CONSTRAINTS", "CONSTRAINT_SCHEMA", "NO", "ASC", "STRING(MAX)"},
  };
  // clang-format on
  return data;
}

// Searches for a metadata entry from metadata_entries. Returns the iterator
// position to the entry if found, or the interator end if not.
template <typename T>
typename std::vector<T>::const_iterator FindMetadata(
    const std::vector<T>* metadata_entries, const std::string& table_name,
    const std::string& column_name) {
  for (auto it = metadata_entries->cbegin(); it != metadata_entries->cend();
       ++it) {
    if (table_name == it->table_name && column_name == it->column_name)
      return it;
  }
  return metadata_entries->cend();
}

// Returns a reference to an information schema column's metadata. The column's
// metadata must exist; otherwise, the process crashes with a fatal message.
const ColumnsMetaEntry& GetColumnMetadata(const zetasql::Table* table,
                                          const zetasql::Column* column) {
  auto m = FindMetadata(ColumnsMetadata(), table->Name(), column->Name());
  if (m == ColumnsMetadata()->end()) {
    ZETASQL_LOG(DFATAL) << "Missing metadata for column " << table->Name() << "."
                << column->Name();
  }
  return *m;
}

// Returns a pointer to an information schema key column's metadata. Returns
// nullptr if not found.
const IndexColumnsMetaEntry* FindKeyColumnMetadata(
    const zetasql::Table* table, const zetasql::Column* column) {
  auto m = FindMetadata(IndexColumnsMetadata(), table->Name(), column->Name());
  return m == IndexColumnsMetadata()->end() ? nullptr : &*m;
}

template <typename T>
std::string PrimaryKeyName(const T* table) {
  return absl::StrCat("PK_", table->Name());
}

template <typename T, typename C>
std::string CheckNotNullName(const T* table, const C* column) {
  return absl::StrCat("CK_IS_NOT_NULL_", table->Name(), "_", column->Name());
}

std::string CheckNotNullClause(absl::string_view column_name) {
  return absl::StrCat(column_name, " IS NOT NULL");
}

// If a foreign key uses the primary key for the referenced table as the
// referenced index, referenced_index() will return nullptr. In this case,
// construct the primary key index name from the table name for information
// schema purposes.
std::string ForeignKeyReferencedIndexName(const ForeignKey* foreign_key) {
  return foreign_key->referenced_index()
             ? foreign_key->referenced_index()->Name()
             : PrimaryKeyName(foreign_key->referenced_table());
}

}  // namespace

InformationSchemaCatalog::InformationSchemaCatalog(const Schema* default_schema)
    : zetasql::SimpleCatalog(kName), default_schema_(default_schema) {
  AddSchemataTable();
  AddSpannerStatisticsTable();
  auto* tables = AddTablesTable();
  auto* columns = AddColumnsTable();
  auto* indexes = AddIndexesTable();
  auto* index_columns = AddIndexColumnsTable();
  AddColumnOptionsTable();
  auto* check_constraints = AddCheckConstraintsTable();
  auto* table_constraints = AddTableConstraintsTable();
  auto* constraint_table_usage = AddConstraintTableUsageTable();
  auto* referential_constraints = AddReferentialConstraintsTable();
  auto* key_column_usage = AddKeyColumnUsageTable();
  auto* constraint_column_usage = AddConstraintColumnUsageTable();

  // These tables are populated only after all tables have been added to the
  // catalog (including meta tables) because they add rows based on the tables
  // in the catalog.
  FillTablesTable(tables);
  FillColumnsTable(columns);
  FillIndexesTable(indexes);
  FillIndexColumnsTable(index_columns);
  FillCheckConstraintsTable(check_constraints);
  FillTableConstraintsTable(table_constraints);
  FillConstraintTableUsageTable(constraint_table_usage);
  FillReferentialConstraintsTable(referential_constraints);
  FillKeyColumnUsageTable(key_column_usage);
  FillConstraintColumnUsageTable(constraint_column_usage);
}

void InformationSchemaCatalog::AddSchemataTable() {
  // Setup table schema.
  auto schemata = new zetasql::SimpleTable(
      "SCHEMATA",
      {{"CATALOG_NAME", StringType()}, {"SCHEMA_NAME", StringType()}});

  // Add table rows.
  std::vector<std::vector<zetasql::Value>> rows;
  rows.push_back({String(""), String("")});
  rows.push_back({String(""), String("INFORMATION_SCHEMA")});

  // Add table to catalog.
  schemata->SetContents(rows);
  AddOwnedTable(schemata);
}

void InformationSchemaCatalog::AddSpannerStatisticsTable() {
  // Setup table schema.
  auto spanner_statistics = new zetasql::SimpleTable(
      "SPANNER_STATISTICS", {{"CATALOG_NAME", StringType()},
                             {"SCHEMA_NAME", StringType()},
                             {"PACKAGE_NAME", StringType()},
                             {"ALLOW_GC", BoolType()}});

  // Skip statistics rows in emulator.

  // Add table to catalog.
  AddOwnedTable(spanner_statistics);
}

zetasql::SimpleTable* InformationSchemaCatalog::AddTablesTable() {
  // Setup table schema.
  auto tables =
      new zetasql::SimpleTable("TABLES", {{"TABLE_CATALOG", StringType()},
                                            {"TABLE_SCHEMA", StringType()},
                                            {"TABLE_TYPE", StringType()},
                                            {"TABLE_NAME", StringType()},
                                            {"PARENT_TABLE_NAME", StringType()},
                                            {"ON_DELETE_ACTION", StringType()},
                                            {"SPANNER_STATE", StringType()}});
  // Add table to catalog so it is included in rows.
  AddOwnedTable(tables);
  return tables;
}

void InformationSchemaCatalog::FillTablesTable(zetasql::SimpleTable* tables) {
  // Add table rows.
  std::vector<std::vector<zetasql::Value>> rows;
  for (const Table* table : default_schema_->tables()) {
    rows.push_back({
        // table_catalog
        String(""),
        // table_schema
        String(""),
        // table_type
        String("BASE TABLE"),
        // table_name
        String(table->Name()),
        // parent_table_name
        table->parent() ? String(table->parent()->Name()) : NullString(),
        // on_delete_action
        table->parent()
            ? String(OnDeleteActionToString(table->on_delete_action()))
            : NullString(),
        // spanner_state,
        String("COMMITTED"),
    });
  }

  for (const auto& table : this->tables()) {
    rows.push_back({
        // table_catalog
        String(""),
        // table_schema
        String(kInformationSchema),
        // table_type
        String("VIEW"),
        // table_name
        String(table->Name()),
        // parent_table_name
        NullString(),
        // on_delete_action
        NullString(),
        // spanner_state,
        NullString(),
    });
  }

  tables->SetContents(rows);
}

zetasql::SimpleTable* InformationSchemaCatalog::AddColumnsTable() {
  // Setup table schema.
  auto columns = new zetasql::SimpleTable(
      "COLUMNS", {{"TABLE_CATALOG", StringType()},
                  {"TABLE_SCHEMA", StringType()},
                  {"TABLE_NAME", StringType()},
                  {"COLUMN_NAME", StringType()},
                  {"ORDINAL_POSITION", Int64Type()},
                  {"COLUMN_DEFAULT", BytesType()},
                  {"DATA_TYPE", StringType()},
                  {"IS_NULLABLE", StringType()},
                  {"SPANNER_TYPE", StringType()},
                  {"IS_GENERATED", StringType()},
                  {"GENERATION_EXPRESSION", StringType()},
                  {"IS_STORED", StringType()},
                  {"SPANNER_STATE", StringType()}});
  AddOwnedTable(columns);
  return columns;
}

void InformationSchemaCatalog::FillColumnsTable(
    zetasql::SimpleTable* columns) {
  // Add table rows.
  std::vector<std::vector<zetasql::Value>> rows;
  for (const Table* table : default_schema_->tables()) {
    int pos = 1;
    for (const Column* column : table->columns()) {
      absl::string_view expression;
      if (column->is_generated()) {
        expression = column->expression().value();
        absl::ConsumePrefix(&expression, "(");
        absl::ConsumeSuffix(&expression, ")");
      }
      rows.push_back({
          // table_catalog
          String(""),
          // table_schema
          String(""),
          // table_name
          String(table->Name()),
          // column_name
          String(column->Name()),
          // ordinal_position
          Int64(pos++),
          // column_default,
          NullBytes(),
          // data_type,
          NullString(),
          // is_nullable
          String(column->is_nullable() ? "YES" : "NO"),
          // spanner_type
          String(ColumnTypeToString(column->GetType(),
                                    column->declared_max_length())),
          // is_generated
          String(column->is_generated() ? "ALWAYS" : "NEVER"),
          // generation_expression
          column->is_generated() ? String(expression) : NullString(),
          // is_stored
          column->is_generated() ? String("YES") : NullString(),
          // spanner_state
          String("COMMITTED"),
      });
    }
  }

  // Add columns for the tables that live inside INFORMATION_SCHEMA.
  for (const auto& table : this->tables()) {
    int pos = 1;
    for (int i = 0; i < table->NumColumns(); ++i) {
      const auto* column = table->GetColumn(i);
      const auto& metadata = GetColumnMetadata(table, column);
      rows.push_back({
          // table_catalog
          String(""),
          // table_schema
          String(kInformationSchema),
          // table_name
          String(table->Name()),
          // column_name
          String(column->Name()),
          // ordinal_position
          Int64(pos++),
          // column_default,
          NullBytes(),
          // data_type,
          NullString(),
          // is_nullable
          String(metadata.is_nullable),
          // spanner_type
          String(metadata.spanner_type),
          // is_generated
          String("NEVER"),
          // generation_expression
          NullString(),
          // is_stored
          NullString(),
          // spanner_state
          NullString(),
      });
    }
  }

  // Add table to catalog.
  columns->SetContents(rows);
}

zetasql::SimpleTable* InformationSchemaCatalog::AddIndexesTable() {
  // Setup table schema.
  auto indexes = new zetasql::SimpleTable(
      "INDEXES", {
                     {"TABLE_CATALOG", StringType()},
                     {"TABLE_SCHEMA", StringType()},
                     {"TABLE_NAME", StringType()},
                     {"INDEX_NAME", StringType()},
                     {"INDEX_TYPE", StringType()},
                     {"PARENT_TABLE_NAME", StringType()},
                     {"IS_UNIQUE", BoolType()},
                     {"IS_NULL_FILTERED", BoolType()},
                     {"INDEX_STATE", StringType()},
                     {"SPANNER_IS_MANAGED", BoolType()},
                 });
  AddOwnedTable(indexes);
  return indexes;
}

void InformationSchemaCatalog::FillIndexesTable(
    zetasql::SimpleTable* indexes) {
  // Add table rows.
  std::vector<std::vector<zetasql::Value>> rows;
  for (const Table* table : default_schema_->tables()) {
    // Add normal indexes.
    for (const Index* index : table->indexes()) {
      rows.push_back({
          // table_catalog
          String(""),
          // table_schema
          String(""),
          // table_name
          String(table->Name()),
          // index_name
          String(index->Name()),
          // index_type
          String("INDEX"),
          // parent_table_name
          String(index->parent() ? index->parent()->Name() : ""),
          // is_unique
          Bool(index->is_unique()),
          // is_null_filtered
          Bool(index->is_null_filtered()),
          // index_state
          String("READ_WRITE"),
          // spanner_is_managed
          Bool(index->is_managed()),
      });
    }

    // Add the primary key index.
    rows.push_back({
        // table_catalog
        String(""),
        // table_schema
        String(""),
        // table_name
        String(table->Name()),
        // index_name
        String("PRIMARY_KEY"),
        // index_type
        String("PRIMARY_KEY"),
        // parent_table_name
        String(""),
        // is_unique
        Bool(true),
        // is_null_filtered
        Bool(false),
        // index_state
        NullString(),
        // spanner_is_managed
        Bool(false),
    });
  }

  // Add the primary key index for tables that live in INFORMATION_SCHEMA.
  for (const auto& table : this->tables()) {
    rows.push_back({
        // table_catalog
        String(""),
        // table_schema
        String(kInformationSchema),
        // table_name
        String(table->Name()),
        // index_name
        String("PRIMARY_KEY"),
        // index_type
        String("PRIMARY_KEY"),
        // parent_table_name
        String(""),
        // is_unique
        Bool(true),
        // is_null_filtered
        Bool(false),
        // index_state
        NullString(),
        // spanner_is_managed
        Bool(false),
    });
  }

  // Add table to catalog.
  indexes->SetContents(rows);
}

zetasql::SimpleTable* InformationSchemaCatalog::AddIndexColumnsTable() {
  // Setup table schema.
  auto index_columns = new zetasql::SimpleTable(
      "INDEX_COLUMNS", {
                           {"TABLE_CATALOG", StringType()},
                           {"TABLE_SCHEMA", StringType()},
                           {"TABLE_NAME", StringType()},
                           {"INDEX_NAME", StringType()},
                           {"INDEX_TYPE", StringType()},
                           {"COLUMN_NAME", StringType()},
                           {"ORDINAL_POSITION", Int64Type()},
                           {"COLUMN_ORDERING", StringType()},
                           {"IS_NULLABLE", StringType()},
                           {"SPANNER_TYPE", StringType()},
                       });

  // Add table to catalog.
  AddOwnedTable(index_columns);
  return index_columns;
}

void InformationSchemaCatalog::FillIndexColumnsTable(
    zetasql::SimpleTable* index_columns) {
  // Add table rows.
  std::vector<std::vector<zetasql::Value>> rows;
  for (const Table* table : default_schema_->tables()) {
    // Add normal indexes.
    for (const Index* index : table->indexes()) {
      int pos = 1;
      // Add key columns.
      for (const KeyColumn* key_column : index->key_columns()) {
        rows.push_back({
            // table_catalog
            String(""),
            // table_schema
            String(""),
            // table_name
            String(table->Name()),
            // index_name
            String(index->Name()),
            // index_type
            String("INDEX"),
            // column_name
            String(key_column->column()->Name()),
            // ordinal_position
            Int64(pos++),
            // column_ordering
            String(key_column->is_descending() ? "DESC" : "ASC"),
            // is_nullable
            String(key_column->column()->is_nullable() &&
                           !index->is_null_filtered()
                       ? "YES"
                       : "NO"),
            // spanner_type
            String(ColumnTypeToString(
                key_column->column()->GetType(),
                key_column->column()->declared_max_length())),
        });
      }

      // Add storing columns.
      for (const Column* column : index->stored_columns()) {
        rows.push_back({
            // table_catalog
            String(""),
            // table_schema
            String(""),
            // table_name
            String(table->Name()),
            // index_name
            String(index->Name()),
            // index_type
            String("INDEX"),
            // column_name
            String(column->Name()),
            // ordinal_position
            NullInt64(),
            // column_ordering
            NullString(),
            // is_nullable
            String(column->is_nullable() ? "YES" : "NO"),
            // spanner_type
            String(ColumnTypeToString(column->GetType(),
                                      column->declared_max_length())),
        });
      }
    }

    // Add the primary key columns.
    {
      int pos = 1;
      for (const KeyColumn* key_column : table->primary_key()) {
        rows.push_back({
            // table_catalog
            String(""),
            // table_schema
            String(""),
            // table_name
            String(table->Name()),
            // index_name
            String("PRIMARY_KEY"),
            // index_type
            String("PRIMARY_KEY"),
            // column_name
            String(key_column->column()->Name()),
            // ordinal_position
            Int64(pos++),
            // column_ordering
            String(key_column->is_descending() ? "DESC" : "ASC"),
            // is_nullable
            String(key_column->column()->is_nullable() ? "YES" : "NO"),
            // spanner_type
            String(ColumnTypeToString(
                key_column->column()->GetType(),
                key_column->column()->declared_max_length())),
        });
      }
    }
  }

  // Add the information schema primary key columns.
  for (const auto& table : this->tables()) {
    int primary_key_ordinal = 1;
    for (int i = 0; i < table->NumColumns(); ++i) {
      const auto* column = table->GetColumn(i);
      const auto* metadata = FindKeyColumnMetadata(table, column);
      if (metadata == nullptr) {
        continue;  // Not a primary key column.
      }
      rows.push_back({
          // table_catalog
          String(""),
          // table_schema
          String(kInformationSchema),
          // table_name
          String(table->Name()),
          // index_name
          String("PRIMARY_KEY"),
          // index_type
          String("PRIMARY_KEY"),
          // column_name
          String(column->Name()),
          // ordinal_position
          Int64(metadata->primary_key_ordinal > 0
                    ? metadata->primary_key_ordinal
                    : primary_key_ordinal++),
          // column_ordering
          String(metadata->column_ordering),
          // is_nullable
          String(metadata->is_nullable),
          // spanner_type
          String(metadata->spanner_type),
      });
    }
  }

  index_columns->SetContents(rows);
}

void InformationSchemaCatalog::AddColumnOptionsTable() {
  // Setup table schema.
  auto columns = new zetasql::SimpleTable("COLUMN_OPTIONS",
                                            {{"TABLE_CATALOG", StringType()},
                                             {"TABLE_SCHEMA", StringType()},
                                             {"TABLE_NAME", StringType()},
                                             {"COLUMN_NAME", StringType()},
                                             {"OPTION_NAME", StringType()},
                                             {"OPTION_TYPE", StringType()},
                                             {"OPTION_VALUE", StringType()}});

  // Add table rows.
  std::vector<std::vector<zetasql::Value>> rows;
  for (const Table* table : default_schema_->tables()) {
    for (const Column* column : table->columns()) {
      if (column->allows_commit_timestamp()) {
        rows.push_back({// table_catalog
                        String(""),
                        // table_schema
                        String(""),
                        // table_name
                        String(table->Name()),
                        // column_name
                        String(column->Name()),
                        // option_name
                        String("allow_commit_timestamp"), String("BOOL"),
                        // option_value
                        String("TRUE")});
      }
    }
  }

  // Add table to catalog.
  columns->SetContents(rows);
  AddOwnedTable(columns);
}

zetasql::SimpleTable* InformationSchemaCatalog::AddTableConstraintsTable() {
  // Setup table schema.
  auto table_constraints = new zetasql::SimpleTable(
      "TABLE_CONSTRAINTS", {
                               {"CONSTRAINT_CATALOG", StringType()},
                               {"CONSTRAINT_SCHEMA", StringType()},
                               {"CONSTRAINT_NAME", StringType()},
                               {"TABLE_CATALOG", StringType()},
                               {"TABLE_SCHEMA", StringType()},
                               {"TABLE_NAME", StringType()},
                               {"CONSTRAINT_TYPE", StringType()},
                               {"IS_DEFERRABLE", StringType()},
                               {"INITIALLY_DEFERRED", StringType()},
                               {"ENFORCED", StringType()},
                           });

  // Add table to catalog.
  AddOwnedTable(table_constraints);
  return table_constraints;
}

void InformationSchemaCatalog::FillTableConstraintsTable(
    zetasql::SimpleTable* table_constraints) {
  std::vector<std::vector<zetasql::Value>> rows;

  // Add the user table constraints.
  for (const auto* table : default_schema_->tables()) {
    // Add the primary key.
    rows.push_back({
        // constraint_catalog
        String(""),
        // constraint_schema
        String(""),
        // constraint_name
        String(PrimaryKeyName(table)),
        // table_catalog
        String(""),
        // table_schema
        String(""),
        // table_name
        String(table->Name()),
        // constraint_type,
        String("PRIMARY KEY"),
        // is_deferrable,
        String("NO"),
        // initially_deferred,
        String("NO"),
        // enforced,
        String("YES"),
    });

    // Add the NOT NULL check constraints.
    for (const auto* column : table->columns()) {
      if (column->is_nullable()) {
        continue;
      }
      rows.push_back({
          // constraint_catalog
          String(""),
          // constraint_schema
          String(""),
          // constraint_name
          String(CheckNotNullName(table, column)),
          // table_catalog
          String(""),
          // table_schema
          String(""),
          // table_name
          String(table->Name()),
          // constraint_type,
          String("CHECK"),
          // is_deferrable,
          String("NO"),
          // initially_deferred,
          String("NO"),
          // enforced,
          String("YES"),
      });
    }

    // Add the check constraints defined by the ZETASQL_CHECK keyword.
    for (const auto* check_constraint : table->check_constraints()) {
      rows.push_back({
          // constraint_catalog
          String(""),
          // constraint_schema
          String(""),
          // constraint_name
          String(check_constraint->Name()),
          // table_catalog
          String(""),
          // table_schema
          String(""),
          // table_name
          String(table->Name()),
          // constraint_type,
          String("CHECK"),
          // is_deferrable,
          String("NO"),
          // initially_deferred,
          String("NO"),
          // enforced,
          String("YES"),
      });
    }

    // Add the foreign keys.
    for (const auto* foreign_key : table->foreign_keys()) {
      rows.push_back({
          // constraint_catalog
          String(""),
          // constraint_schema
          String(""),
          // constraint_name
          String(foreign_key->Name()),
          // table_catalog
          String(""),
          // table_schema
          String(""),
          // table_name
          String(table->Name()),
          // constraint_type,
          String("FOREIGN KEY"),
          // is_deferrable,
          String("NO"),
          // initially_deferred,
          String("NO"),
          // enforced,
          String("YES"),
      });

      // Add the foreign key's unique backing index as a unique constraint.
      if (foreign_key->referenced_index()) {
        rows.push_back({
            // constraint_catalog
            String(""),
            // constraint_schema
            String(""),
            // constraint_name
            String(foreign_key->referenced_index()->Name()),
            // table_catalog
            String(""),
            // table_schema
            String(""),
            // table_name
            String(foreign_key->referenced_table()->Name()),
            // constraint_type,
            String("UNIQUE"),
            // is_deferrable,
            String("NO"),
            // initially_deferred,
            String("NO"),
            // enforced,
            String("YES"),
        });
      }
    }
  }

  // Add the information schema constraints.
  for (const auto* table : this->tables()) {
    // Add the primary key.
    rows.push_back({
        // constraint_catalog
        String(""),
        // constraint_schema
        String(kInformationSchema),
        // constraint_name
        String(PrimaryKeyName(table)),
        // table_catalog
        String(""),
        // table_schema
        String(kInformationSchema),
        // table_name
        String(table->Name()),
        // constraint_type
        String("PRIMARY KEY"),
        // is_deferrable,
        String("NO"),
        // initially_deferred
        String("NO"),
        // enforced
        String("YES"),
    });

    // Add the NOT NULL check constraints.
    for (int i = 0; i < table->NumColumns(); ++i) {
      const auto* column = table->GetColumn(i);
      const auto& metadata = GetColumnMetadata(table, column);
      if (IsNullable(metadata)) {
        continue;
      }
      rows.push_back({
          // constraint_catalog
          String(""),
          // constraint_schema
          String(kInformationSchema),
          // constraint_name
          String(CheckNotNullName(table, column)),
          // table_catalog
          String(""),
          // table_schema
          String(kInformationSchema),
          // table_name
          String(table->Name()),
          // constraint_type,
          String("CHECK"),
          // is_deferrable,
          String("NO"),
          // initially_deferred,
          String("NO"),
          // enforced,
          String("YES"),
      });
    }
  }

  table_constraints->SetContents(rows);
}

zetasql::SimpleTable* InformationSchemaCatalog::AddCheckConstraintsTable() {
  // Setup table schema.
  auto check_constraints = new zetasql::SimpleTable(
      "CHECK_CONSTRAINTS", {
                               {"CONSTRAINT_CATALOG", StringType()},
                               {"CONSTRAINT_SCHEMA", StringType()},
                               {"CONSTRAINT_NAME", StringType()},
                               {"CHECK_CLAUSE", StringType()},
                               {"SPANNER_STATE", StringType()},
                           });

  // Add table to catalog.
  AddOwnedTable(check_constraints);
  return check_constraints;
}

void InformationSchemaCatalog::FillCheckConstraintsTable(
    zetasql::SimpleTable* check_constraints) {
  std::vector<std::vector<zetasql::Value>> rows;

  // Add the user table check constraints.
  for (const auto* table : default_schema_->tables()) {
    // Add the NOT NULL check constraints.
    for (const auto* column : table->columns()) {
      if (column->is_nullable()) {
        continue;
      }
      rows.push_back({
          // constraint_catalog
          String(""),
          // constraint_schema
          String(""),
          // constraint_name
          String(CheckNotNullName(table, column)),
          // check clause
          String(CheckNotNullClause(column->Name())),
          // spanner state
          String("COMMITTED"),
      });
    }

    // Add the check constraints defined by the ZETASQL_CHECK keyword.
    for (const auto* check_constraint : table->check_constraints()) {
      rows.push_back({
          // constraint_catalog
          String(""),
          // constraint_schema
          String(""),
          // constraint_name
          String(check_constraint->Name()),
          // check clasue
          String(check_constraint->expression()),
          // spanner state
          String("COMMITTED"),
      });
    }
  }

  // Add the information schema constraints.
  for (const auto* table : this->tables()) {
    // Add the NOT NULL check constraints.
    for (int i = 0; i < table->NumColumns(); ++i) {
      const auto* column = table->GetColumn(i);
      const auto& metadata = GetColumnMetadata(table, column);
      if (IsNullable(metadata)) {
        continue;
      }
      rows.push_back({
          // constraint_catalog
          String(""),
          // constraint_schema
          String(kInformationSchema),
          // constraint_name
          String(CheckNotNullName(table, column)),
          // check clause
          String(CheckNotNullClause(column->Name())),
          // spanner state
          String("COMMITTED"),
      });
    }
  }
  check_constraints->SetContents(rows);
}

zetasql::SimpleTable*
InformationSchemaCatalog::AddConstraintTableUsageTable() {
  // Setup table schema.
  auto constraint_table_usage = new zetasql::SimpleTable(
      "CONSTRAINT_TABLE_USAGE", {
                                    {"TABLE_CATALOG", StringType()},
                                    {"TABLE_SCHEMA", StringType()},
                                    {"TABLE_NAME", StringType()},
                                    {"CONSTRAINT_CATALOG", StringType()},
                                    {"CONSTRAINT_SCHEMA", StringType()},
                                    {"CONSTRAINT_NAME", StringType()},
                                });

  // Add table to catalog.
  AddOwnedTable(constraint_table_usage);
  return constraint_table_usage;
}

void InformationSchemaCatalog::FillConstraintTableUsageTable(
    zetasql::SimpleTable* constraint_table_usage) {
  std::vector<std::vector<zetasql::Value>> rows;

  // Add the user table constraints.
  for (const auto* table : default_schema_->tables()) {
    // Add the primary key.
    rows.push_back({
        // table_catalog
        String(""),
        // table_schema
        String(""),
        // table_name
        String(table->Name()),
        // constraint_catalog
        String(""),
        // constraint_schema
        String(""),
        // constraint_name
        String(PrimaryKeyName(table)),
    });

    // Add the NOT NULL check constraints.
    for (const auto* column : table->columns()) {
      if (column->is_nullable()) {
        continue;
      }
      rows.push_back({
          // table_catalog
          String(""),
          // table_schema
          String(""),
          // table_name
          String(table->Name()),
          // constraint_catalog
          String(""),
          // constraint_schema
          String(""),
          // constraint_name
          String(CheckNotNullName(table, column)),
      });
    }

    // Add the check constraints defined by the ZETASQL_CHECK keyword.
    for (const auto* check_constraint : table->check_constraints()) {
      rows.push_back({
          // table_catalog
          String(""),
          // table_schema
          String(""),
          // table_name
          String(table->Name()),
          // constraint_catalog
          String(""),
          // constraint_schema
          String(""),
          // constraint_name
          String(check_constraint->Name()),
      });
    }

    // Add the foreign keys.
    for (const auto* foreign_key : table->foreign_keys()) {
      rows.push_back({
          // table_catalog
          String(""),
          // table_schema
          String(""),
          // table_name
          String(foreign_key->referenced_table()->Name()),
          // constraint_catalog
          String(""),
          // constraint_schema
          String(""),
          // constraint_name
          String(foreign_key->Name()),
      });

      // Add the foreign key's unique backing index as a unique constraint.
      if (foreign_key->referenced_index()) {
        rows.push_back({
            // table_catalog
            String(""),
            // table_schema
            String(""),
            // table_name
            String(foreign_key->referenced_table()->Name()),
            // constraint_catalog
            String(""),
            // constraint_schema
            String(""),
            // constraint_name
            String(foreign_key->referenced_index()->Name()),
        });
      }
    }
  }

  // Add the information schema constraints.
  for (const auto* table : this->tables()) {
    // Add the primary key.
    rows.push_back({
        // table_catalog
        String(""),
        // table_schema
        String(kInformationSchema),
        // table_name
        String(table->Name()),
        // constraint_catalog
        String(""),
        // constraint_schema
        String(kInformationSchema),
        // constraint_name
        String(PrimaryKeyName(table)),
    });

    // Add the NOT NULL check constraints.
    for (int i = 0; i < table->NumColumns(); ++i) {
      const auto* column = table->GetColumn(i);
      const auto& metadata = GetColumnMetadata(table, column);
      if (IsNullable(metadata)) {
        continue;
      }
      rows.push_back({
          // table_catalog
          String(""),
          // table_schema
          String(kInformationSchema),
          // table_name
          String(table->Name()),
          // constraint_catalog
          String(""),
          // constraint_schema
          String(kInformationSchema),
          // constraint_name
          String(CheckNotNullName(table, column)),
      });
    }
  }

  constraint_table_usage->SetContents(rows);
}

zetasql::SimpleTable*
InformationSchemaCatalog::AddReferentialConstraintsTable() {
  // Setup table schema.
  auto referential_constraints = new zetasql::SimpleTable(
      "REFERENTIAL_CONSTRAINTS",
      {
          {"CONSTRAINT_CATALOG", StringType()},
          {"CONSTRAINT_SCHEMA", StringType()},
          {"CONSTRAINT_NAME", StringType()},
          {"UNIQUE_CONSTRAINT_CATALOG", StringType()},
          {"UNIQUE_CONSTRAINT_SCHEMA", StringType()},
          {"UNIQUE_CONSTRAINT_NAME", StringType()},
          {"MATCH_OPTION", StringType()},
          {"UPDATE_RULE", StringType()},
          {"DELETE_RULE", StringType()},
          {"SPANNER_STATE", StringType()},
      });

  // Add table to catalog.
  AddOwnedTable(referential_constraints);
  return referential_constraints;
}

void InformationSchemaCatalog::FillReferentialConstraintsTable(
    zetasql::SimpleTable* referential_constraints) {
  std::vector<std::vector<zetasql::Value>> rows;

  // Add the foreign key constraints.
  for (const auto* table : default_schema_->tables()) {
    for (const auto* foreign_key : table->foreign_keys()) {
      rows.push_back({
          // constraint_catalog
          String(""),
          // constraint_schema
          String(""),
          // constraint_name
          String(foreign_key->Name()),
          // unique_constraint_catalog
          String(""),
          // unique_constraint_schema
          String(""),
          // unique_constraint_name
          String(ForeignKeyReferencedIndexName(foreign_key)),
          // match_option
          String("SIMPLE"),
          // update_rule
          String("NO ACTION"),
          // delete_rule
          String("NO ACTION"),
          // spanner_state
          String("COMMITTED"),
      });
    }
  }

  referential_constraints->SetContents(rows);
}

zetasql::SimpleTable* InformationSchemaCatalog::AddKeyColumnUsageTable() {
  // Setup table schema.
  auto key_column_usage = new zetasql::SimpleTable(
      "KEY_COLUMN_USAGE", {
                              {"CONSTRAINT_CATALOG", StringType()},
                              {"CONSTRAINT_SCHEMA", StringType()},
                              {"CONSTRAINT_NAME", StringType()},
                              {"TABLE_CATALOG", StringType()},
                              {"TABLE_SCHEMA", StringType()},
                              {"TABLE_NAME", StringType()},
                              {"COLUMN_NAME", StringType()},
                              {"ORDINAL_POSITION", Int64Type()},
                              {"POSITION_IN_UNIQUE_CONSTRAINT", Int64Type()},
                          });

  // Add table to catalog.
  AddOwnedTable(key_column_usage);
  return key_column_usage;
}

void InformationSchemaCatalog::FillKeyColumnUsageTable(
    zetasql::SimpleTable* key_column_usage) {
  std::vector<std::vector<zetasql::Value>> rows;

  for (const auto* table : default_schema_->tables()) {
    // Add the primary key columns.
    int table_ordinal = 1;
    for (const auto* key_column : table->primary_key()) {
      rows.push_back({
          // constraint_catalog
          String(""),
          // constraint_schema
          String(""),
          // constraint_name
          String(PrimaryKeyName(table)),
          // table_catalog
          String(""),
          // table_schema
          String(""),
          // table_name
          String(table->Name()),
          // column_name
          String(key_column->column()->Name()),
          // ordinal_position
          Int64(table_ordinal++),
          // position_in_unique_constraint
          NullString(),
      });
    }

    // Add the foreign keys.
    for (const auto* foreign_key : table->foreign_keys()) {
      // Add the foreign key referencing columns.
      int foreign_key_ordinal = 1;
      for (const auto* column : foreign_key->referencing_columns()) {
        rows.push_back({
            // constraint_catalog
            String(""),
            // constraint_schema
            String(""),
            // constraint_name
            String(foreign_key->Name()),
            // table_catalog
            String(""),
            // table_schema
            String(""),
            // table_name
            String(table->Name()),
            // column_name
            String(column->Name()),
            // ordinal_position
            Int64(foreign_key_ordinal),
            // position_in_unique_constraint
            Int64(foreign_key_ordinal),
        });
        ++foreign_key_ordinal;
      }

      // Add the foreign key's unique backing index columns.
      if (foreign_key->referenced_index()) {
        int index_ordinal = 1;
        for (const auto* key_column :
             foreign_key->referenced_index()->key_columns()) {
          rows.push_back({
              // constraint_catalog
              String(""),
              // constraint_schema
              String(""),
              // constraint_name
              String(foreign_key->referenced_index()->Name()),
              // table_catalog
              String(""),
              // table_schema
              String(""),
              // table_name
              String(foreign_key->referenced_table()->Name()),
              // column_name
              String(key_column->column()->Name()),
              // ordinal_position
              Int64(index_ordinal++),
              // position_in_unique_constraint
              NullInt64(),
          });
        }
      }
    }
  }

  // Add the information schema primary key columns.
  for (const auto& table : this->tables()) {
    int primary_key_ordinal = 1;
    for (int i = 0; i < table->NumColumns(); ++i) {
      const auto* column = table->GetColumn(i);
      const auto* metadata = FindKeyColumnMetadata(table, column);
      if (metadata == nullptr) {
        continue;  // Not a primary key column.
      }
      rows.push_back({
          // constraint_catalog
          String(""),
          // constraint_schema
          String(kInformationSchema),
          // constraint_name
          String(PrimaryKeyName(table)),
          // table_catalog
          String(""),
          // table_schema
          String(kInformationSchema),
          // table_name
          String(table->Name()),
          // column_name
          String(metadata->column_name),
          // ordinal_position
          Int64(metadata->primary_key_ordinal > 0
                    ? metadata->primary_key_ordinal
                    : primary_key_ordinal++),
          // position_in_unique_constraint
          NullString(),
      });
    }
  }

  key_column_usage->SetContents(rows);
}

zetasql::SimpleTable*
InformationSchemaCatalog::AddConstraintColumnUsageTable() {
  // Setup table schema.
  auto constraint_column_usage = new zetasql::SimpleTable(
      "CONSTRAINT_COLUMN_USAGE", {
                                     {"TABLE_CATALOG", StringType()},
                                     {"TABLE_SCHEMA", StringType()},
                                     {"TABLE_NAME", StringType()},
                                     {"COLUMN_NAME", StringType()},
                                     {"CONSTRAINT_CATALOG", StringType()},
                                     {"CONSTRAINT_SCHEMA", StringType()},
                                     {"CONSTRAINT_NAME", StringType()},
                                 });

  // Add table to catalog.
  AddOwnedTable(constraint_column_usage);
  return constraint_column_usage;
}

void InformationSchemaCatalog::FillConstraintColumnUsageTable(
    zetasql::SimpleTable* constraint_column_usage) {
  std::vector<std::vector<zetasql::Value>> rows;

  for (const auto* table : default_schema_->tables()) {
    // Add the primary key columns.
    for (const auto* key_column : table->primary_key()) {
      rows.push_back({
          // table_catalog
          String(""),
          // table_schema
          String(""),
          // table_name
          String(table->Name()),
          // column_name
          String(key_column->column()->Name()),
          // constraint_catalog
          String(""),
          // constraint_schema
          String(""),
          // constraint_name
          String(PrimaryKeyName(table)),
      });
    }

    // Add the NOT NULL check constraints.
    for (const auto* column : table->columns()) {
      if (column->is_nullable()) {
        continue;
      }
      rows.push_back({
          // table_catalog
          String(""),
          // table_schema
          String(""),
          // table_name
          String(table->Name()),
          // column_name
          String(column->Name()),
          // constraint_catalog
          String(""),
          // constraint_schema
          String(""),
          // constraint_name
          String(CheckNotNullName(table, column)),
      });
    }

    // Add the check constraints defined by the ZETASQL_CHECK keyword.
    for (const auto* check_constraint : table->check_constraints()) {
      for (const auto* dep_column : check_constraint->dependent_columns()) {
        rows.push_back({
            // table_catalog
            String(""),
            // table_schema
            String(""),
            // table_name
            String(table->Name()),
            // column_name
            String(dep_column->Name()),
            // constraint_catalog
            String(""),
            // constraint_schema
            String(""),
            // constraint_name
            String(check_constraint->Name()),
        });
      }
    }

    // Add the foreign keys.
    for (const auto* foreign_key : table->foreign_keys()) {
      // Add the foreign key referenced columns.
      for (const auto* column : foreign_key->referenced_columns()) {
        rows.push_back({
            // table_catalog
            String(""),
            // table_schema
            String(""),
            // table_name
            String(foreign_key->referenced_table()->Name()),
            // column_name
            String(column->Name()),
            // constraint_catalog
            String(""),
            // constraint_schema
            String(""),
            // constraint_name
            String(foreign_key->Name()),
        });
      }

      // Add the foreign key's unique backing index columns.
      if (foreign_key->referenced_index()) {
        for (const auto* key_column :
             foreign_key->referenced_index()->key_columns()) {
          rows.push_back({
              // table_catalog
              String(""),
              // table_schema
              String(""),
              // table_name
              String(foreign_key->referenced_table()->Name()),
              // column_name
              String(key_column->column()->Name()),
              // constraint_catalog
              String(""),
              // constraint_schema
              String(""),
              // constraint_name
              String(foreign_key->referenced_index()->Name()),
          });
        }
      }
    }
  }

  // Add the information schema primary key columns.
  for (const auto& table : this->tables()) {
    for (int i = 0; i < table->NumColumns(); ++i) {
      const auto* column = table->GetColumn(i);
      const auto* metadata = FindKeyColumnMetadata(table, column);
      if (metadata == nullptr) {
        continue;  // Not a primary key column.
      }
      rows.push_back({
          // table_catalog
          String(""),
          // table_schema
          String(kInformationSchema),
          // table_name
          String(table->Name()),
          // column_name
          String(metadata->column_name),
          // constraint_catalog
          String(""),
          // constraint_schema
          String(kInformationSchema),
          // constraint_name
          String(PrimaryKeyName(table)),
      });
    }
  }

  // Add the information schema NOT NULL check constraints.
  for (const auto& table : this->tables()) {
    for (int i = 0; i < table->NumColumns(); ++i) {
      const auto* column = table->GetColumn(i);
      const auto& metadata = GetColumnMetadata(table, column);
      if (IsNullable(metadata)) {
        continue;
      }
      rows.push_back({
          // table_catalog
          String(""),
          // table_schema
          String(kInformationSchema),
          // table_name
          String(table->Name()),
          // column_name
          String(metadata.column_name),
          // constraint_catalog
          String(""),
          // constraint_schema
          String(kInformationSchema),
          // constraint_name
          String(CheckNotNullName(table, column)),
      });
    }
  }

  constraint_column_usage->SetContents(rows);
}

}  // namespace backend
}  // namespace emulator
}  // namespace spanner
}  // namespace google
