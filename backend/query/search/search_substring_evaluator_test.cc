//
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

#include "backend/query/search/search_substring_evaluator.h"

#include <string>
#include <utility>
#include <vector>

#include "zetasql/public/value.h"
#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "zetasql/base/testing/status_matchers.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "backend/query/search/plain_full_text_tokenizer.h"
#include "backend/query/search/tokenizer.h"

namespace google {
namespace spanner {
namespace emulator {
namespace backend {
namespace query {
namespace search {

using testing::HasSubstr;
using zetasql_base::testing::StatusIs;

// The test suite focuses on verifying the safety code that handles unexpected
// input for SearchSubstringEvaluator class since they indicate abnormal status
// in the process. Normal test scenarios (including customer misusing of the
// function) are covered in search_test.cc.

TEST(SearchSubstringEvaluatorTest, EvaluateWrongSearchColumnType) {
  std::vector<zetasql::Value> args;
  args.push_back(zetasql::Value::Bool(false));
  args.push_back(zetasql::Value::String("test"));

  EXPECT_THAT(
      SearchSubstringEvaluator::Evaluate(args),
      StatusIs(
          absl::StatusCode::kInvalidArgument,
          HasSubstr("Invalid search query. Trying to execute search related "
                    "function on unsupported column type: BOOL.")));
}

TEST(SearchSubstringEvaluatorTest, EvaluateWrongSearchQueryType) {
  std::vector<zetasql::Value> args;
  args.push_back(TokenListFromStrings({}));
  args.push_back(zetasql::Value::Bool(false));

  EXPECT_THAT(SearchSubstringEvaluator::Evaluate(args),
              StatusIs(absl::StatusCode::kInvalidArgument,
                       HasSubstr("Invalid search query type: BOOL.")));
}

TEST(SearchSubstringEvaluatorTest, EvaluateOnWrongTokenList) {
  std::vector<zetasql::Value> args;
  const auto fulltext_tokenlist =
      PlainFullTextTokenizer::Tokenize({zetasql::Value::String("fulltext")});
  args.push_back(*fulltext_tokenlist);
  args.push_back(zetasql::Value::String("test"));

  EXPECT_THAT(
      SearchSubstringEvaluator::Evaluate(args),
      StatusIs(absl::StatusCode::kInvalidArgument,
               HasSubstr("SEARCH_SUBSTRING function's first argument must be a "
                         "TOKENLIST column generated by TOKENIZE_SUBSTRING")));
}

TEST(SearchSubstringEvaluatorTest, EvaluateOnNullTokenList) {
  std::vector<zetasql::Value> args;
  args.push_back(zetasql::Value::NullTokenList());
  args.push_back(zetasql::Value::String("test"));

  const auto result = SearchSubstringEvaluator::Evaluate(args);
  EXPECT_TRUE(result->is_null());
}

TEST(SearchSubstringEvaluatorTest, EvaluateOnEmptyTokenList) {
  std::vector<zetasql::Value> args;
  args.push_back(TokenListFromStrings({""}));
  args.push_back(zetasql::Value::String("test"));

  EXPECT_THAT(
      SearchSubstringEvaluator::Evaluate(args),
      StatusIs(absl::StatusCode::kInvalidArgument,
               HasSubstr("SEARCH_SUBSTRING function's first argument must be a "
                         "TOKENLIST column generated by TOKENIZE_SUBSTRING")));
}

struct SubstringTokenizerSignatureTestCase {
  std::string tokenizer_sig;
};

using SubstringTokenizerSignatureTest =
    ::testing::TestWithParam<SubstringTokenizerSignatureTestCase>;

TEST_P(SubstringTokenizerSignatureTest, TestTokenizerSignature) {
  const SubstringTokenizerSignatureTestCase& test_case = GetParam();
  std::vector<zetasql::Value> args;
  args.push_back(TokenListFromStrings({test_case.tokenizer_sig}));
  args.push_back(zetasql::Value::String("test"));

  EXPECT_THAT(SearchSubstringEvaluator::Evaluate(args),
              StatusIs(absl::StatusCode::kInternal));
};

INSTANTIATE_TEST_SUITE_P(SubstringTokenizerSignatureTest,
                         SubstringTokenizerSignatureTest,
                         testing::ValuesIn<SubstringTokenizerSignatureTestCase>(
                             {{"substring-4"},
                              {"substring-true-4"},
                              {"substring-4-0.1"},
                              {"substring-4-0.1-0"}}));

struct BasicSubstringEvaluatorTestCase {
  std::vector<std::string> list_of_tokens;
  std::string query;
  bool expected_result;
};

using BasicSubstringEvaluatorTest =
    ::testing::TestWithParam<BasicSubstringEvaluatorTestCase>;

TEST_P(BasicSubstringEvaluatorTest, BasicEvaluateSearch) {
  const BasicSubstringEvaluatorTestCase& test_case = GetParam();
  std::vector<std::string> tokens;
  tokens.reserve(test_case.list_of_tokens.size() + 1);
  tokens.push_back("substring-4-1-0-0");
  tokens.insert(tokens.end(), test_case.list_of_tokens.begin(),
                test_case.list_of_tokens.end());

  std::vector<zetasql::Value> args;
  args.push_back(TokenListFromStrings(tokens));
  args.push_back(zetasql::Value::String(test_case.query));

  absl::StatusOr<zetasql::Value> result =
      SearchSubstringEvaluator::Evaluate(args);
  ZETASQL_EXPECT_OK(result.status());
  EXPECT_EQ(result.value().bool_value(), test_case.expected_result);
};

INSTANTIATE_TEST_SUITE_P(
    BasicSubstringEvaluatorTest, BasicSubstringEvaluatorTest,
    testing::ValuesIn<BasicSubstringEvaluatorTestCase>({
        {{"google", "cloud", "spanner", "emulator"}, "ou", true},
        {{"google", "cloud", "spanner", "emulator"}, "uo", false},
        {{"google", "cloud", "spanner", "emulator"}, "oo ou", true},
        {{"google", "cloud", "spanner", "emulator"}, "oo, uo", false},
    }));

TEST_F(BasicSubstringEvaluatorTest, RelativeSearchTypeNotMatch) {
  std::vector<std::string> tokens;
  tokens.push_back("substring-4-1-0-1");  // supports 'word_prefix'
  tokens.push_back("google");

  std::vector<zetasql::Value> args;
  args.push_back(TokenListFromStrings(tokens));
  args.push_back(zetasql::Value::String("oo"));
  args.push_back(zetasql::Value::String("word_suffix"));

  EXPECT_THAT(SearchSubstringEvaluator::Evaluate(args),
              StatusIs(absl::StatusCode::kInvalidArgument,
                       HasSubstr("The referenced substring TOKENLIST is not "
                                 "tokenized with 'word_suffix' support")));

  // No match for "word_prefix"
  args.pop_back();
  args.push_back(zetasql::Value::String("word_prefix"));
  absl::StatusOr<zetasql::Value> result =
      SearchSubstringEvaluator::Evaluate(args);
  ZETASQL_EXPECT_OK(result.status());
  EXPECT_EQ(result.value().bool_value(), false);

  // Got hit if relative_search_type is not specified.
  args.pop_back();
  result = SearchSubstringEvaluator::Evaluate(args);
  ZETASQL_EXPECT_OK(result.status());
  EXPECT_EQ(result.value().bool_value(), true);
}

TEST_F(BasicSubstringEvaluatorTest, RelativeSearchPhraseInputTooShort) {
  std::vector<std::string> tokens;
  tokens.push_back("substring-6-5-0-16");  // supports 'phrase'
  tokens.push_back("blah");

  std::vector<zetasql::Value> args;
  args.push_back(TokenListFromStrings(tokens));
  args.push_back(zetasql::Value::String("la"));
  args.push_back(zetasql::Value::String("phrase"));

  absl::StatusOr<zetasql::Value> result =
      SearchSubstringEvaluator::Evaluate(args);
  ZETASQL_EXPECT_OK(result.status());
  EXPECT_EQ(result.value().bool_value(), false);
}

}  // namespace search
}  // namespace query
}  // namespace backend
}  // namespace emulator
}  // namespace spanner
}  // namespace google
