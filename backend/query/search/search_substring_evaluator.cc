//
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

#include "backend/query/search/search_substring_evaluator.h"

#include <algorithm>
#include <string>
#include <vector>

#include "zetasql/public/functions/string.h"
#include "zetasql/public/value.h"
#include "absl/container/flat_hash_set.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/match.h"
#include "absl/strings/numbers.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/str_join.h"
#include "absl/strings/str_split.h"
#include "absl/strings/string_view.h"
#include "absl/types/span.h"
#include "backend/query/search/tokenizer.h"
#include "common/errors.h"
#include "zetasql/base/ret_check.h"
#include "zetasql/base/status_macros.h"

namespace google {
namespace spanner {
namespace emulator {
namespace backend {
namespace query {
namespace search {

// Read the tokenlist value. Read the tokenization function signature to get the
// ngram sizes used to tokenize the original document. Also return a list of
// tokens generated by tokenization function.
// In tokenlist: the tokenlist value store in the generated column.
// Out source_is_null: true if the source value is NULL.
// Out relative_search_types: enum flags indicating supported relative search
// types.
// Out ngram_min_size: the minimum ngram size used to tokenize the source.
// Out token_list: the list of tokens to search from.
absl::Status SearchSubstringEvaluator::BuildTokenList(
    const zetasql::Value& tokenlist, bool& source_is_null,
    int& relative_search_types, int& ngram_min_size,
    std::vector<std::string>& token_list) {
  constexpr int kNgramMinSizeIndex = 2;
  constexpr int kIsNullIndex = 3;
  constexpr int kRelativeSearchTypeIndex = 4;

  ZETASQL_ASSIGN_OR_RETURN(auto tokens, StringsFromTokenList(tokenlist));
  ngram_min_size = 12;  // max allowed ngrams size.
  for (int i = 0; i < tokens.size(); ++i) {
    if (IsTokenizerSignature(tokens[i])) {
      // There will be multiple signatures when tokenlist is concatenated.
      if (!absl::StartsWith(tokens[i], kSubstringTokenizer)) {
        return error::TokenListNotMatchSearch("SEARCH_SUBSTRING",
                                              "TOKENIZE_SUBSTRING");
      }
      // substring tokenizer signature in the format of
      // substring
      //  -ngram_size_max
      //  -ngram_size_min
      //  -is_source_null
      //  -relative_search_types
      std::vector<std::string> signature =
          absl::StrSplit(tokens[i], absl::ByChar('-'), absl::SkipEmpty());
      int current_ngram_size_min = 0;
      ZETASQL_RET_CHECK(signature.size() == kSubstringTokenizerSignatureArgumentSize &&
                absl::SimpleAtoi(signature[kNgramMinSizeIndex],
                                 &current_ngram_size_min) &&
                current_ngram_size_min > 0 &&
                absl::SimpleAtoi(signature[kRelativeSearchTypeIndex],
                                 &relative_search_types));
      source_is_null = signature[kIsNullIndex] != "0";
      ngram_min_size = std::min(ngram_min_size, current_ngram_size_min);
    } else if (i == 0) {
      return error::TokenListNotMatchSearch("SEARCH_SUBSTRING",
                                            "TOKENIZE_SUBSTRING");
    } else {
      ZETASQL_RETURN_IF_ERROR(TokenizeSubstring(tokens[i], token_list));
    }
  }

  return absl::OkStatus();
}

bool SearchSubstringEvaluator::MatchesSubstring(
    absl::Span<const std::string> token_list, absl::string_view substring,
    RelativeSearchType relative_search_type) {
  if (token_list.empty()) {
    return false;
  }

  if (relative_search_type == RelativeSearchType::None) {
    for (auto& token : token_list) {
      if (absl::StrContains(token, substring)) {
        return true;
      }
    }
  }

  if (relative_search_type == RelativeSearchType::Word_Prefix) {
    for (auto& token : token_list) {
      if (absl::StartsWith(token, substring)) {
        return true;
      }
    }
  }

  if (relative_search_type == RelativeSearchType::Word_Suffix) {
    for (auto& token : token_list) {
      if (absl::EndsWith(token, substring)) {
        return true;
      }
    }
  }

  if (relative_search_type == RelativeSearchType::Value_Prefix) {
    if (absl::StartsWith(token_list[0], substring)) {
      return true;
    }
  }

  if (relative_search_type == RelativeSearchType::Value_Suffix) {
    const std::string& last_token = token_list.back();
    if (absl::EndsWith(last_token, substring)) {
      return true;
    }
  }

  return false;
}

zetasql::Value SearchSubstringEvaluator::SearchSubstring(
    int ngram_min_size, absl::Span<const std::string> tokens,
    absl::Span<const std::string> substrings,
    RelativeSearchType relative_search_type) {
  // substring search requires matching on every token in the search query
  absl::flat_hash_set<std::string> token_set(tokens.begin(), tokens.end());
  for (auto& ss : substrings) {
    // Any substring with length shorter than ngram_min_size will return false
    // unless the substring is found as an entire token.
    // If there is any substring is not found, return false.
    bool found = (token_set.contains(ss) || ss.length() >= ngram_min_size) &&
                 MatchesSubstring(tokens, ss, relative_search_type);
    if (!found) {
      return zetasql::Value::Bool(false);
    }
  }
  // return true if all tokens return match or query does not contain token.
  return zetasql::Value::Bool(true);
}

zetasql::Value SearchSubstringEvaluator::SearchSubstringPharse(
    int ngram_min_size, absl::Span<const std::string> tokens,
    absl::Span<const std::string> substrings) {
  std::string substring_phrase = absl::StrJoin(substrings, " ");
  if (substring_phrase.length() < ngram_min_size) {
    // If the phrase's length is less than ngram_min_size, add leading and
    // trailing spaces. E.g. when ngram_min_size = 5, and substring is "bar",
    // which only has 3 characters, if the relative_search_type is None, it
    // will not be a match since the length of the substring is smaller than
    // the ngram_min_size. However, when relative_search_type is "phrase",
    // we will still consider it as a match. A counter example is "lah", with
    // the document having "blah", this will not match in either None or
    // Phrase cases.
    substring_phrase = absl::StrCat(" ", substring_phrase, " ");
  }

  // Add leading and trailing spaces to facilitate handling the special case
  // above.
  std::string token_string = absl::StrCat(" ", absl::StrJoin(tokens, " "), " ");
  if (substring_phrase.length() >= ngram_min_size &&
      absl::StrContains(token_string, substring_phrase)) {
    return zetasql::Value::Bool(true);
  }

  return zetasql::Value::Bool(false);
}

absl::StatusOr<zetasql::Value> SearchSubstringEvaluator::Evaluate(
    absl::Span<const zetasql::Value> args) {
  const zetasql::Value& tokenlist = args[kTokenlist];
  const zetasql::Value& query = args[kQuery];

  if (!tokenlist.type()->IsTokenList()) {
    return error::ColumnNotSearchable(tokenlist.type()->DebugString());
  }

  if (!query.type()->IsString()) {
    return error::InvalidQueryType(query.type()->DebugString());
  }

  if (tokenlist.is_null()) {
    return zetasql::Value::NullBool();
  }

  int ngram_min_size = 12;  // max allowed ngrams size.
  std::vector<std::string> token_list;
  bool source_is_null;
  int tokenizer_relative_search_types = 0;

  ZETASQL_RETURN_IF_ERROR(BuildTokenList(tokenlist, source_is_null,
                                 tokenizer_relative_search_types,
                                 ngram_min_size, token_list));

  // If relative_search_type is not specified, using None as default.
  RelativeSearchType requested_search_type = RelativeSearchType::None;
  if (args.size() > kRelativeSearchType &&
      !args[kRelativeSearchType].is_null()) {
    ZETASQL_ASSIGN_OR_RETURN(
        requested_search_type,
        ParseRelativeSearchType(args[kRelativeSearchType].string_value()));
    if ((tokenizer_relative_search_types & requested_search_type) == 0) {
      return error::RelativeSearchNotSupported(
          args[kRelativeSearchType].string_value());
    }
  }

  if (source_is_null || query.is_null()) {
    // Either document is empty or query is null, always return false
    return zetasql::Value::NullBool();
  }

  std::string lower_str;
  absl::Status status;
  zetasql::functions::LowerUtf8(query.string_value(), &lower_str, &status);
  ZETASQL_RETURN_IF_ERROR(status);

  std::vector<std::string> substrings = absl::StrSplit(
      lower_str, absl::ByAnyChar(kDelimiter), absl::SkipWhitespace());

  if (substrings.empty()) {
    // Query is empty, always return false
    return zetasql::Value::Bool(false);
  }

  if (substrings.size() > 1 &&
      requested_search_type != RelativeSearchType::Phrase &&
      requested_search_type != RelativeSearchType::None) {
    // It is not possible for any word to have multiple prefixes/suffixes.
    return zetasql::Value::NullBool();
  }

  if (requested_search_type != RelativeSearchType::Phrase) {
    return SearchSubstring(ngram_min_size, token_list, substrings,
                           requested_search_type);
  }

  return SearchSubstringPharse(ngram_min_size, token_list, substrings);
}

}  // namespace search
}  // namespace query
}  // namespace backend
}  // namespace emulator
}  // namespace spanner
}  // namespace google
