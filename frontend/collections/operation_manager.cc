//
// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

#include "frontend/collections/operation_manager.h"

#include <map>
#include <memory>
#include <string>

#include "zetasql/base/statusor.h"
#include "absl/strings/match.h"
#include "absl/strings/str_cat.h"
#include "absl/synchronization/mutex.h"
#include "common/errors.h"
#include "frontend/common/uris.h"

namespace google {
namespace spanner {
namespace emulator {
namespace frontend {

const char OperationManager::kAutoGeneratedId[] = "";

zetasql_base::StatusOr<std::shared_ptr<Operation>> OperationManager::CreateOperation(
    const std::string& resource_uri, const std::string& operation_id) {
  absl::MutexLock lock(&mu_);

  // Generate an operation id if the user did not specify one.
  std::string operation_uri = MakeOperationUri(
      resource_uri, operation_id.empty()
                        ? absl::StrCat("_auto", next_operation_id_++)
                        : operation_id);

  // Double-check that the operation does not already exist.
  auto itr = operations_map_.find(operation_uri);
  if (itr != operations_map_.end()) {
    return error::OperationAlreadyExists(operation_uri);
  }

  // Finally, create the operation.
  std::shared_ptr<Operation> operation =
      std::make_shared<Operation>(operation_uri);
  operations_map_[operation_uri] = operation;

  return operation;
}

zetasql_base::StatusOr<std::shared_ptr<Operation>> OperationManager::GetOperation(
    const std::string& operation_uri) {
  absl::MutexLock lock(&mu_);

  auto itr = operations_map_.find(operation_uri);
  if (itr == operations_map_.end()) {
    return error::OperationNotFound(operation_uri);
  }
  return itr->second;
}

absl::Status OperationManager::DeleteOperation(
    const std::string& operation_uri) {
  absl::MutexLock lock(&mu_);
  operations_map_.erase(operation_uri);
  return absl::OkStatus();
}

zetasql_base::StatusOr<std::vector<std::shared_ptr<Operation>>>
OperationManager::ListOperations(const std::string& resource_uri) {
  absl::MutexLock lock(&mu_);
  std::vector<std::shared_ptr<Operation>> operations;
  auto itr = operations_map_.lower_bound(resource_uri);
  while (itr != operations_map_.end()) {
    if (!absl::StartsWith(itr->first, resource_uri)) {
      break;
    }
    operations.push_back(itr->second);
    ++itr;
  }

  return operations;
}

}  // namespace frontend
}  // namespace emulator
}  // namespace spanner
}  // namespace google
